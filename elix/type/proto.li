Header
  + name := PROTO;
  
Inherit
  + parent_tok_drw:Expanded TOK_DRW
  - parent_any:ANY := ANY
 // - parent_lix_buf:LIX_BUF := LIX_BUF
FILE_CFG
  - list:Expanded ARRAY PROTO
  
Public
  - get_proto n:STRING_ALIAS :PROTO <- list.search_until { b:PROTO; b.src.name = n}
  
  + web_path:STRING_ALIAS
    
  + key:STRING_ALIAS; // Name (\0 generic) Used for key in TPRO.
  //- name:STRING_ALIAS <- (crash; key)
  
  - hash_code:INTEGER <- src.name.hash_code
  
  + type:TPRO; // Used for display tree inherit
      
  + src:LIX_BUF
  
  + type_c:EXT
  + default:EXPR
  + export:TTOK
  + import:TTOK
  + lip:EXPR
  + extern_c:EXT
      
  + child_insert:Expanded ARRAY SLOT
  + child_inherit:Expanded ARRAY SLOT
    
  + slot:Expanded ARRAY SLOT; // Inherit Or Insert, ...
  //+ slot:HMAP SLOT KEY STRING_ALIAS
    
  - collect_parent s:SLOT :ARRAY SLOT <-
  (
    set_op.clear; set_cl.clear
    set_cl.add s to (s.name_id)
    collect_rec_parent s
    set_op
  )
  
  - collect_child s:SLOT :(ARRAY SLOT,ARRAY SLOT) <-
  (
    set_op.clear; set_op2.clear; set_proto.clear
    collect_rec_child s
    set_op,set_op2
  )
  
Private
   
  - set_op:ARRAY SLOT := ARRAY SLOT.create_with_capacity 32
  - set_op2:ARRAY SLOT := ARRAY SLOT.create_with_capacity 32
  - set_cl:HMAP SLOT KEY STRING_ALIAS := HMAP SLOT KEY STRING_ALIAS.create
  - set_proto:HSET PROTO := HSET PROTO.create
  
  - collect_chapter lst:ARRAY SLOT eye y:BOOLEAN access p:PROTO <-
  ( + i:INTEGER
    + s:SLOT
    + pp:PROTO
    + new_y:BOOLEAN
    {(i <= slot.upper) && {(s := slot.at i).section.is_parent}}.while_do {
      pp := s.type.like TPRO.proto
      (pp != NULL).if {
        new_y := y & s.eye_open
        pp.collect_local_chapter lst eye new_y access p
        pp.collect_chapter lst eye new_y access p
      }
      i := i + 1
    }
  )
  
  - collect_local_chapter lst:ARRAY SLOT eye y:BOOLEAN access p:PROTO <-
  (
    slot.foreach { s:SLOT
      ({s.section.access p} && {! set_op.fast_has s} && {! set_cl.fast_has (s.name_id)}).if {
        (y).if { lst.add_last s; } else { set_cl.add s to (s.name_id); }
      }
    }
  )
  
  - collect_rec_parent s:SLOT <-
  ( + i,cnt:INTEGER
    + p,r:SLOT
    + pp:PROTO
    cnt := set_op.count
    {(i <= slot.upper) && {cnt = set_op.count} && {(p := slot.at i).section.is_parent}}.while_do {
      pp := p.type.like TPRO.proto
      (pp != NULL).if {        
        r := pp.lookup (s.name_id) filter 01
        (r != NULL).if { set_op.add_last r; }
        pp.collect_rec_parent s
      }
      i := i + 1
    }
  )
  
  - collect_rec_child s:SLOT <-
  ( 
    child_inherit.foreach { sl:SLOT; sl.proto.add_child_slot s in set_op }
    child_insert .foreach { sl:SLOT; sl.proto.add_child_slot s in set_op2}
  )
  
Private

  - add_child_slot s:SLOT in o:ARRAY SLOT <-
  ( + r:SLOT
    (! set_proto.fast_has Self).if {
      set_proto.fast_add_without_control Self
      r := lookup (s.name_id) filter 01
      (r != NULL).if { o.add_last r; }
    }
    collect_rec_child s
  )
  
Public
  
  /*- parent b:{SLOT; BOOLEAN} :INTEGER <-
  ( + i:INTEGER
    {
      (i <= slot_order.upper) &&
      {(slot_order.at i.section.flag & SECTION.p_insert) != 0} &&
      {b.value (slot_order.at i)}
    }.while_do {
      i := i + 1
    }
    i
  );*/
  
  + ss:Expanded ARRAY BUNDLE
  - ss_new t:TYPE :INTEGER <-
  ( + result:INTEGER
    result := ss.count
    (t = NULL).if {
      ss.add_last (BUNDLE.new (TYPE.void))
    } else {
      t.foreach { tt:TONE
        ss.add_last (BUNDLE.new tt)
      }
    }
    result
  )

Public
  
  - new:SELF <- clone
  
  - init pth:STRING_ALIAS web wp:STRING_ALIAS :SELF <-
  ( web_path := wp
    list.add_last Self
    src := LIX_BUF.new.init pth proto Self    
    src.load_file
    //pth.println
    //0.to (src.upper) do { i:INTEGER; src.at i.print; }; '\n'.print
    parse_name
    Self
  )
  
  - parse_name <-
  ( + n:STRING_BUFFER
    + nod:NODE
    + ts:ARRAY TYPE
    + t:TPRO
    n := STRING.new_tmp
    parent_txt_buf := src
    pos_i := 0
    //(name.has_suffix "truc.li").if { upper.println; }
    (upper = 0).if { src.like LIX_BUF.pre_create; }
    word "Section"
    (! word "Header").if {
      err syntax msg "`Header' is needed.";
    }
    { skip_sp; }.do_while {read_c '\n'}
    // NAME:
    (((! read_c '+') && {! read_c '-'}) || {! word "name"}).if {
      err syntax msg "name needed."
    }
    (! word ":=").if { err syntax msg ":="; }; skip_sp
    //
    (word "Expanded") || {word "Strict"}
    nod := NODE.rtype
    ts := push_type
    /*
    (name.has_suffix "/z.li").if {
      skip_sp
      read_cap_idf.println;
      UTF8.is_upper "ℤ".println;
      UTF8.print;
    };*/
    {read_cap_idf}.while_do {      
      (last_str.count = 1).if {
        n.add_last '\0'
        ts.add_last (TP.letter (last_str.first - 'A'))
        nod := nod.n_arg NULL rec FALSE
      } else {
        STRING.tmp { tmp:STRING_BUFFER; // BSBS: bof
          tmp.copy last_str
          //(nod = NULL).if { OUT # "Bug read: " # src.name # '\n'; }
          nod := nod.n_idf tmp
        }
        n.append last_str
      }
    }
    (n.is_empty).if { err syntax msg "name is needed."; }
    //
    nod.set_proto Self
    key := n.to_string_alias
    t := TPRO.new Self gen ts attr 0
    type := t
    pop_type
    n.free_tmp
    //
    TYPE.init_base key with t
  )
  
  //- load:BUFFER <- src.load
        
  - lookup n:STRING_ALIAS filter m:UINTEGER_8 :SLOT <-
  // 01:Local
  // 10:Parent
  // 100: Debug
  [ ? {m.in_range 1 to 7}; ]
  ( + result:SLOT
    + i:INTEGER
    + to:TPRO
    ((m & 01b) = 01b).if {
      {(i <= slot.upper) && {result = NULL}}.while_do {
        (slot.at i.name_id = n).if { result := slot.at i; }
        i := i + 1
      }
    }
    // *** Debug
    ((m & 100b) = 100b).if {
      n.print; " In ".print; type.print; slot.count.print
      (result = NULL).if { " not found.\n".print; } else { " Found !".println; }
    }
    // ***
    ((result = NULL) && {(m & 10b) = 10b}).if {      
      i := 0
      {
        (i <= slot.upper) &&
        {(slot.at i.section.flag & SECTION.p_insert) != 0} &&
        {result = NULL}
      }.while_do {
        to ?= slot.at i.type
        // *** DEBUG
        ((m & 100b) = 100b).if {
          " Go ".print; (to != NULL).if { to.proto.type.println; }
        }
        // ***
        (to != NULL).if { result := to.proto.lookup n filter (m|1); }
        i := i + 1
      }
    }
    result
  )
  
  - lookup n:NODE :SLOT <-
  ( + result:SLOT
    result := n.search_slot_in Self
    (result = NULL).if {
      parent { s:SLOT; (result := s.type.lookup n ) = NULL }
    }
    result
  )
  
  //
  // PARSER / DRAW
  //
  
  + tname:TTOK
  + rmk_b:INTEGER
  + rmk_e:INTEGER
  
Private
  - order:INTEGER
  - test_order n:INTEGER <-
  (
    (order > n).if {err warning msg "Order: Comment, type, default, export, import, lip, external !";}
    order := n
  )
  
Public
  
  - add_field:INTEGER
  
  - look_hdr c:STRING :BOOLEAN <-
  ( + i:INTEGER
    + l:CHARACTER
    { i := i + 1; }.do_while {(i < 4) && {skip_line}}
    i := 0
    {((l := at (pos_i+i)) != '\0') && {i <= c.upper} && {l = c.at i}}.while_do { i := i + 1; }
    ! (i <= c.upper).if {
      pos_i := Old pos_i
    }
  )
  
  - parse <-
  ( + fuck:BOOLEAN
    //+ v:BOOLEAN
    //+ i,p:INTEGER
    //+ s:SLOT
    //+ t:TPRO
    order := 0
    //v := name.has_suffix "hello.li"
    //v.if {
    //name.println
    //}
    word "Section"
    (! word "Header").if { err syntax msg "`Header' is needed."; };
    skip_spln
    // NAME:
    (((! read_c '+') && {!read_c '-'}) || {!word "name"}).if {
      err syntax msg "name needed."
    }
    (! word ":=").if { err syntax msg ":="; }; skip_sp
    tname := TTOK.parse_sp (TTOK.tpro | TTOK.force)
    ? {tname.db > 0}
    (tname.type = NULL).if {
      //+ c:CHARACTER;
      err warning msg "Type not found.";
      /*
      col (LOOK.erro) sub 0
      {((c := at pos_i) != '\0') && {c != '\n'} && {c != ';'}}.while_do {
        pos_i := pos_i + 1;
      };
      */  
    }    
    (look ";").if { pos_i := pos_i + 1; }
    skip_line
    //"PROTO:".print; pos_i.pt.print; ' '.print; name.println
    // COMMENT & OPTIONS:
    fuck := FALSE
    // Read Comment
    (look_hdr "/*").if {
      + col:INTEGER
      rmk_b := pos_i + 2
      col := sty.count+1
      rd_rem_c
      sty.at col put (LOOK.rmk)
      rmk_e := pos_i-2
      skip_line
    }
    // Options
    type_c   ?= field 2 name "- type"     ass ":=" value "``" parse {EXT.parse_sp 1}
    default  ?= field 3 name "- default"  ass ":=" value ""   parse {EXPR.parse_sp (1 | EXPR.force)}
    export   ?= field 4 name "- export"   ass ":=" value ""   parse {TTOK.parse_sp (TTOK.tvec | TTOK.force)}
    import   ?= field 5 name "- import"   ass ":=" value ""   parse {TTOK.parse_sp (TTOK.tvec | TTOK.force)}
    lip      ?= field 6 name "- lip"      ass "<-" value ""   parse {EXPR.parse_sp (1 | EXPR.force)}
    extern_c ?= field 7 name "- external" ass ":=" value "``" parse {EXT.parse_sp 1}
    //
    skip_line
    /*
    ((pos_i = upper) || {at pos_i.is_upper}).if_false {
      0.to 600 do { i:INTEGER; at i.print; }
      '\n'.print
      src.name.println
      "\nIncorrect format!".println
      "pos_i=".print; pos_i.pt.println
      exit 1
    }
    ? {(pos_i = upper) || {at pos_i.is_upper}}
    */
  )
  
  - field id:INTEGER name n:STRING_ALIAS ass ass:STRING_ALIAS value v:STRING_ALIAS parse p:{TOK_ITM} :TOK_ITM <-
  ( + cur:POS
    + pg:TXT_PG
    + result:TOK_ITM
    (look_hdr n).if { pos_i := pos_i + n.count; test_order id
      (! word ass).if { err syntax msg ass; }
      result := p.value
      read_c ';'
      skip_line
    }.elseif {(add_field = id) && {PAGE.cur_pg.buf_pg.buffer = src}} then {
      add_field := 0
      (at pos_i = '\n').if { pos_i := pos_i + 1; } else {
        {at (pos_i-1) = ' '}.while_do { pos_i := pos_i - 1; }
      }
      src.intern_at pos_i add "  "; pos_i := pos_i + 2
      src.intern_at pos_i add n;    pos_i := pos_i + n.count
      src.intern_at pos_i add " ";  pos_i := pos_i + 1
      src.intern_at pos_i add ass;  pos_i := pos_i + ass.count
      src.intern_at pos_i add " ";  pos_i := pos_i + 1
      cur := pos_i
      src.intern_at pos_i add v;    pos_i := pos_i + v.count
      src.intern_at pos_i add "\n"
      pos_i := cur
      pg ?= PAGE.cur_pg.buf_pg
      pg.set_pos (cur.pt + v.count/2)
      result := p.value
      read_c ';'
      skip_line
    }
    result
  )
  
  - parse_local <-
  (
    sty.clear
    pos_i := 0
    tok_cur := 0
    nl := 0
    begin pos_i
    parse
    end pos_i
  )
  
  + open_win:CHARACTER := '0'
  
  - draw <-
  (    
    ? {pos_i.pt = 0}
    begin pos_i
    styi := 0
    //print_sty 0
    tex.add_x (100)
    begin_line; tex.ascdes (asc_c,des_c)
    pos_i := POS.new_ico 0
    DIV.new.ico (LOOK.comment) alpha 1 act
    {b:DIV; open_win := (open_win = '1').ok '0' or '1'; }
    DIV.new.ico (LOOK.card)    alpha 1 act
    {b:DIV; open_win := (open_win = '2').ok '0' or '2'; }
    DIV.new.ico (LOOK.inherit) alpha 1 act
    {b:DIV; open_win := (open_win = '3').ok '0' or '3'; }
    tex.add_x 30
    draw_itm tname
    //
    draw_nothing
    draw_comment
    draw_card
    draw_inherit
    pos_i := di
    //OUT # "Draw = " # di # '\n'
    dh := tex.y - Old tex.y
  )
  
  + collect_slot:ARRAY SLOT
  - collect_slot_parent <-
  (
    (collect_slot = NULL).if { collect_slot := ARRAY SLOT.create_with_capacity 128; } else { collect_slot.clear; }
    set_cl.clear
    collect_local_chapter collect_slot eye FALSE access Self
    collect_chapter collect_slot eye TRUE access Self
    
  )
   
  - draw_extern_slot k:STRING_ALIAS idx i:INTEGER :INTEGER <-  
  // Used by Chapter 
  ( + p:INTEGER
    p := i
    collect_slot.foreach { s:SLOT
      (((s.chapter = NULL) && {k = NULL}) || {(s.chapter != NULL) && {s.chapter.key = k}}).if {        
        pos_i := POS.new_ico p
        p := p + 1
        begin_line
        DIV.new.draw_out s
        end_line
      }
    }
    pos_i := Old pos_i
    p
  )
  
  - draw_extern_slot_other <-
  ( - keyset:HSET STRING_ALIAS
    + chap:CHAPTER
    + k:STRING_ALIAS
    + p:INTEGER
    (keyset = NULL).if { keyset := HSET STRING_ALIAS.create; } else { keyset.clear; }
    collect_slot.foreach { s:SLOT
      ((s.chapter != NULL) && {s.chapter.key != NULL}).if {
        keyset.fast_add (s.chapter.key)
      }
    }
    0.to (src.toks.upper) do { i:INTEGER
      chap ?= src.toks.at i
      ((chap != NULL) && {chap.key != NULL}).if {
        keyset.fast_remove (chap.key)
      }
    }
    p := draw_extern_slot NULL idx p
    (keyset.lower).to (keyset.upper) do { i:INTEGER
      k := keyset.at i
      CHAPTER.draw_extern_key k
      p := draw_extern_slot k idx p
    }
  )
  
Private
  
  - tmp_str:STRING_BUFFER := STRING_BUFFER.create 64
  
  - draw_nothing <-
  ( + e0,e1,x,y,p2:REAL_32
    + p:PAINT
    + col1,col0:COLOR
    (e0,e1) := (1,8)
    
    p2 := REAL_32.pi/2
    col1 := LOOK.header
    col0 := COLOR.white; //rgba (col0.ri,col0.gi,col0.bi,0)
    (open_win = '0').if {
      (x,y) := (tex.x+x_space,tex.y + e1 + e1)
      begin_path
      arc (x,y) radius e1 angle (p2,-p2) direction 2
      p := PAINT.create_radial (x,y+e1) radius (0,e1) color col0 to col1
      fill_paint p
      fill
      p.free
      //
      begin_path
      move_to (x,y-e1)
      //line_to (tex.xmax,y-e1)
      arc (tex.xmax,y-e0) radius e0 angle (-p2,p2) direction 2
      line_to (x,y+e1)
      p := PAINT.create_linear (x,y+e1) to (x,y) color col0 to col1
      fill_paint p
      fill
      p.free
      //
      tex.add_y (e1*3 + hline_default)
      /*
      begin_path
      stroke_color (COLOR.red)
      line (tex.x,tex.y) to (tex.x+200,tex.y)
      stroke
      */
    }
  )
  
  - border id:INTEGER do blc:{} <-
  ( + xb,x0,y0,ye,x,y,r0,r1,e0,e1,p2:REAL_32
    + d:WIN
    + col1,col0:COLOR
    + p:PAINT
    (r0,r1) := (20,80)
    (e0,e1) := (4,8)
    col1 := LOOK.header
    col0 := COLOR.white; //rgba (col0.ri,col0.gi,col0.bi,0)
    
    //stroke_width 1
    //stroke_color (COLOR.black)
    
    d := child.at id
    p2 := REAL_32.pi/2
    (x0,y0) := (d.xo + d.width/2, d.ymax + e0 + 2)
    (x,y) := (x0+e0,y0)
    xb := tex.x + x_space
    begin_path
    move_to (x,y)
    arc (x-r0,y+1) radius r0 angle (0,p2) direction 2
    x := xb + e1
    y := y + r0
    ye := y+r1
    arc (x+r1, ye) radius (r1-1) angle (-p2,REAL_32.pi) direction 1
    p := PAINT.create_radial (xb+r1,y+r1) radius (r1-e1,r1) color col0 to col1
    //
    x := xb - e1
    arc (x+r1+2, ye) radius (r1+2) angle (REAL_32.pi,-p2) direction 2
    (x,y) := (x0-e0,y0)
    arc (x-r0+2,y) radius (r0-2) angle (p2,0) direction 1
    arc (x0,y0) radius e0 angle (REAL_32.pi,0) direction 2
    fill_paint p
    fill
    p.free
    //
    tex.push (x_space*3,r0 + 30)
    blc.value
    //
    (ye < tex.y).if {
      begin_path
      (x,y) := (xb,ye)
      p := PAINT.create_linear (x+e1,ye) to (x,y) color col0 to col1
      rect (x-e1,ye) to (x+e1,tex.y-1)
      fill_paint p
      fill
      p.free
      ye := tex.y
    }
    //
    begin_path
    (x,y) := (xb,ye)
    arc (x,y) radius e1 angle (0,REAL_32.pi) direction 2
    p := PAINT.create_radial (x+e1,y) radius (0,e1) color col0 to col1
    fill_paint p
    fill
    p.free
    //    
    tex.pop_add_y hline_default
  )
  
  //
  // Comment
  //
  
  - draw_comment <-
  ( + e:INTEGER
    + old_pt:POS
    + x,y,w:REAL_32
    + c:CHARACTER
    (open_win != '1').if {
      // Nothing.
    } else {
      (rmk_b = 0).if {
        pos_i := tname.de
        skip_until '\n'
        pos_i := pos_i + 1
        set_pos (pos_i+4)
        src.intern_at pos_i add "  /**/\n"
        parse_local
      }
      border (open_win -! '1') do {
        pos_i := rmk_b
        begin_line
        //fill_color (LOOK.cols.at (LOOK.rmk))
        last_div := DIV.new.text
        tex.ascdes (asc_c,des_c)
        {pos_i.pt < rmk_e}.while_do {
          old_pt := pos_i
          sty_run
          (old_pt = pos_i).if {
            at_tmp pos_i
            ((c := tmp_c.first) = ' ').if {
              e := pos_i+1
              {(e <= upper) && {e < rmk_e} && {at e != ' '} && {at e != '\n'}}.while_do { e := e + 1; }
              (e <= upper).if {
                tmp_str.clear; from pos_i to (e-1) in tmp_str
                (w,x,y,x,y) := text_bounds (tex.x,tex.y) msg tmp_str
                (tex.x + w > width-x_space*3).if { c := '\n'; }
              }
            }
            (c = '\n').if {
              end_line
              begin_line
            } else {
              draw_tmp_c
            }
            pos_i := pos_i + tmp_c.count
          }
        }
        //end_line
        end_text
      }
    }
  )
  
  //
  // Card
  //
  
  - draw_card <-
  ( + cpt:INTEGER
    - menu:BOOLEAN
    (open_win != '2').if {
      // Nothing.
      menu := FALSE
    } else {
      border (open_win -! '1') do {        
        begin_line
        DIV.ico (LOOK.path) alpha 1 act NULL
        fill_color (LOOK.directive)
        text (tex.x,tex.y) msg (src.name)
        end_line
        //
        STRING.tmp { tmp:STRING_BUFFER
          date_create.append_ddmmyy_in tmp
          tmp += " ↦ "; // tmp += " ➔ "
          date_update.append_ddmmyy_in tmp
          begin_line
          DIV.ico (LOOK.calendar) alpha 1 act NULL
          fill_color (LOOK.directive)
          text (tex.x,tex.y) msg tmp
          end_line
        }
        //
        cpt :=
        draw_field type_c   img (LOOK.type_c)  +
        draw_field default  img (LOOK.default) +
        draw_field export   img (LOOK.export)  +
        draw_field import   img (LOOK.import)  +
        draw_field lip      img (LOOK.lip)     +
        draw_field extern_c img (LOOK.extern_c)
        (cpt != 6).if {
          pos_i := POS.new_ico 3; // Comment+Card+Inherit
          begin_line
          ((!menu) || {PAGE.cur_pg.buf_pg.buffer != src}).if {            
            DIV.new.drw {
              fill_color (COLOR.gray)
              tex.ascdes (asc_c,des_c)
              tex.set_x (text (tex.x,tex.y) msg " + ")
            } act { b:DIV; menu := TRUE; }
          } else {
            (type_c = NULL).if { DIV.new.ico (LOOK.type_c) alpha 0.3 act
              { b:DIV; add_field := 2; menu := FALSE; parse_local; }
            }
            (default = NULL).if { DIV.new.ico (LOOK.default) alpha 0.3 act
              { b:DIV; add_field := 3; menu := FALSE; parse_local; }
            }
            (export = NULL).if { DIV.new.ico (LOOK.export) alpha 0.3 act
              { b:DIV; add_field := 4; menu := FALSE; parse_local; }
            }
            (import = NULL).if { DIV.new.ico (LOOK.import) alpha 0.3 act
              { b:DIV; add_field := 5; menu := FALSE; parse_local; }
            }
            (lip = NULL).if { DIV.new.ico (LOOK.lip) alpha 0.3 act
              { b:DIV; add_field := 6; menu := FALSE; parse_local; }
            }
            (extern_c = NULL).if { DIV.new.ico (LOOK.extern_c) alpha 0.3 act
              { b:DIV; add_field := 7; menu := FALSE; parse_local; }
            }
          }
          end_line
          pos_i := pt_b + di; // Fix Hook Point
        }
      }
    }
  )
  
  - icon img:IMG <-
  (
    begin_line
    DIV.ico img alpha 1 act NULL
  )
  
  - draw_itm t:TOK_ITM <-
  (    
    pos_i := t.db
    last_div := DIV.new.text
    tex.ascdes (asc_c,des_c)
    t.draw
    end_text
  )
  
  - draw_field t:TOK_ITM img img:IMG :INTEGER <-
  ( + result,i:INTEGER
    + c:CHARACTER
    + after:BOOLEAN
    (t != NULL).if {      
      (
        (t.dd = 0) &&
        {PAGE.cur_pg.buf_pg.buffer = src} &&
        {PAGE.cur_pg.buf_pg.like TXT_PG.pos.pt != t.db} // pti
      ).if {
        //"Suppr".println
        after := (pos > pos_i); // pti ptoi
        pos_i := t.db
        skip_until '\n'
        pos_i := pos_i - 1
        {
          c := at pos_i
          buf.remove pos_i
          pos_i := pos_i - 1
          i := i + 1
        }.do_while {c != '\n'}
        parse_local
        pos_i := 0
        (after).if {
          pos := pos - i
          //(pti  != -1).if { pti  := pti  - i; }
          //(ptoi != -1).if { ptoi := ptoi - i; }
        }
        
      } else {
        //"Draw".println
        //t.dd.println
        icon img; draw_itm t
        result := 1
      }
    }
    result
  )
  
  //
  // Inherit 
  //
  
  - hset_proto:HSET PROTO KEY STRING_ALIAS := HSET PROTO KEY STRING_ALIAS.create
  - margin_h:REAL_32 := 16
  - hbox:REAL_32 := 40
  - eye_width:REAL_32 := 40
  
  - col_typ0:COLOR := COLOR.rgba (255,255,255,10)
  - col_typ1:COLOR := COLOR.rgba (255,255,255,30)
  
  - draw_inherit <-
  ( + x1,y1,x2,y2,xm,a,d,y3:REAL_32
    + beg_div,v:INTEGER
    + div:DIV
    (open_win != '3').if {
      // Nothing.
    } else {
      border (open_win -! '1') do {
        beg_div := child.count
        v := 3; // Comment+Card+Inherit
        lisave
        hset_proto.clear
        //
        (x1,y1) := draw_parent Self to (tex.x,0)
        child_inherit.quick_sort_with {(s0,s1:SLOT); s0.proto.key < s1.proto.key}
        child_insert .quick_sort_with {(s0,s1:SLOT); s0.proto.key < s1.proto.key}
        (x2,y2) := draw_child  Self to (tex.x,0)
        //
        xm := x1.max x2
        //
        lisave
        (x1,a,d) := draw_to (0,0); //type.proto.draw_to (0,0)
        xm := xm.max (tex.x + x1)
        restore_to ((tex.x + xm - x1)/2,a + (hbox - a + d)/2)
        //
        begin_path; line (tex.x,0) to (xm,0); line (tex.x,hbox) to (xm,hbox)
        stroke_color (LOOK.header); stroke_width 3.0; stroke
        // Sort DIV        
        child.quick_sort {(a,b:WIN)
          + r:BOOLEAN
          ((a.ymax - b.ymax).abs > FONT.size_app).if {
            r := a.ymax < b.ymax
          } else {
            r := a.xo < b.xo
          }
          r
        } from beg_div to (child.upper)
        (beg_div).to (child.upper) do { i:INTEGER
          div ?= child.at i
          //div.ptov.print; "->".print
          div.set_pos (POS.new_ico v) pte (POS.new_ico v)
          //v.println
          v := v + 1
        }
        //
        restore_to (0,tex.y-y1)
        tex.set_y (tex.y-y1+y2)
        //
        y3 := draw_map v
        tex.add_y y3
      }
    }
  )
  
  - draw_parent p:PROTO to (x,y:REAL_32) :(REAL_32,REAL_32) <-
  ( + px,py,tx,ty:REAL_32
    + tt:TPRO
    + j:INTEGER
    + s:SLOT
    (px,py) := (x,y)
    hset_proto.very_fast_add p
    {(j <= p.slot.upper) && {(s := p.slot.at j).section.is_parent}}.while_do {      
      tt ?= s.type
      (hset_proto.fast_reference_at (tt.proto) = NULL).if {        
        py := py - (hbox + 50)
        arrow_up s from (px+20, y) to (py+hbox + 2)
        (tx,ty) := (px,py)
        (px,py) := draw_parent (tt.proto) to (px,py)
        px := drw_type s to (tx,ty,px)
      }
      j := j + 1
    }
    px,py
  )
  
  - draw_child p:PROTO to (x,y:REAL_32) :(REAL_32,REAL_32) <-
  ( + px,py,tx,ty,px_max, py_max,ox,oy:REAL_32
    px_max := x
    px := x + 100
    py := y + hbox + 20
    p.child_inherit.foreach { s:SLOT
      oy := py+hbox/2
      arrow_h s from (px,oy) to (x+20)
      (tx,ty) := draw_child (s.proto) to (px,py)
      px_max := px_max.max (drw_proto s to (px,py,tx))
      py := ty
    }
    (! p.child_inherit.is_empty).if { arrow_v (x+20,oy) to (y+hbox+2) dotted FALSE; }
    py_max := py
    //
    ox := px_max + 20; // Margin Inherit <-> Insert
    px := ox + 100
    oy := py := y + hbox + 20
    p.child_insert.foreach { s:SLOT
      oy := py+hbox/2
      arrow_h s from (px,oy) to (ox+20)
      (tx,ty) := draw_child (s.proto) to (px,py)
      px_max := px_max.max (drw_proto s to (px,py,tx))
      py := ty
    }
    (! p.child_insert.is_empty).if { arrow_v (ox+20,oy) to (y+hbox+2) dotted TRUE; }
    py_max := py_max.max py
    px_max,py_max
  )
  
  - drw_type s:SLOT to (x,y,xm:REAL_32) :REAL_32 <-
  ( + px,a,d:REAL_32
    + be,en:INTEGER
    + tpro:TPRO
    be := trace_pointer
    lisave
    tpro ?= s.ttok.type
    (px,a,d) := s.draw_type_extern_to (x+margin_h,y)
    //(px,a,d) := tpro.proto.draw_to (x+margin_h,y)
    restore_to (0,a + (hbox - a + d)/2); en := trace_pointer
    //
    px := px + margin_h
    px := px + eye_width
    px := px.max xm
    border (x,y) to (px,y+hbox) col ((s.proto = Self).ok col_typ1 or col_typ0)
    //    
    s.draw_eye (px-eye_width,y+asc_c+4)
    //
    foreground be to en
    px
  )
  
  - drw_proto s:SLOT to (x,y,xm:REAL_32) :REAL_32 <-
  ( + px,a,d:REAL_32
    + be,en:INTEGER
    be := trace_pointer; lisave
    //(px,a,d) := s.draw_type_extern_to (x+margin_h,y)
    (px,a,d) := s.proto.draw_to (x+margin_h,y)
    px := px.max xm
    restore_to (0,a + (hbox - a + d)/2); en := trace_pointer
    border (x,y) to (px+margin_h,y+hbox) col col_typ0
    foreground be to en
    px
  )
    
  - border (x0,y0:REAL_32) to (x1,y1:REAL_32) col c:COLOR <-
  ( begin_path; rect (x0,y0) to (x1,y1) radius 8
    fill_color c; fill
    stroke_width 3.0; stroke_color (LOOK.header); stroke
  )
       
  - arrow_up s:SLOT from (x,y0:REAL_32) to (y1:REAL_32) <-
  ( + py:REAL_32
    LOOK.clone (s.clonable) exp FALSE to (x-12,y0-2)
    //DCHAR.clone (s.clonable) exp (s.expanded) to (x-10,y0-2)
    begin_path
    line_cap butt; //square
    py := y0 - 20
    (s.section.is_insert).if {
      line_p (x,py) to (x,y1)
      //{py > y1}.while_do { line (x, py) to (x,(py - 3).max y1); py := py - 8; }
    } else {
      line (x, py) to (x,y1)
    }
    move_to (x-8,y1+8); line_to (x,y1); line_to (x+8,y1+8)
    stroke_width 3
    stroke_color (LOOK.none)
    stroke
  )
  
  - arrow_h s:SLOT from (x0,y:REAL_32) to (x1:REAL_32) <-
  ( + px:REAL_32
    px := x0 - 20 - s.clonable.ok 7 or 0
    LOOK.clone (s.clonable) exp FALSE to (px-1,y + 8)
    //DCHAR.clone (s.clonable) exp (s.expanded) to (px,y + 8)
    begin_path
    line_cap butt
    (s.section.is_insert).if {
      line_p (px,y) to (x1,y)
      //{px > x1}.while_do { line (px, y) to ((px-3).max x1,y); px := px - 8; }
    } else {
      line (px,y) to (x1,y)
    }
    stroke_width 3
    stroke_color (LOOK.none)
    stroke
  )
  
  - arrow_v (x,y0:REAL_32) to (y1:REAL_32) dotted t:BOOLEAN <-
  ( + py:REAL_32
    begin_path
    line_cap butt
    py := y0
    (t).if {
      //{py > y1}.while_do { line (x, py) to (x,(py - 3).max y1); py := py - 8; }
      line_p (x,y0) to (x,y1)
    } else {
      line (x,y0) to (x,y1)
    }
    move_to (x-8,y1+8); line_to (x,y1); line_to (x+8,y1+8)
    stroke_width 3
    stroke_color (LOOK.none)
    stroke
  )
  
  //
  // MAP
  //
  
  - draw_map div_id:INTEGER :REAL_32 <-
  ( + x,y,py,px:REAL_32
    
    pos_i := POS.new_ico div_id
    
    begin_path
    stroke_color (LOOK.none)
    line (tex.x,tex.y) to (width-tex.x,tex.y)
    stroke_width 1
    stroke
    //
    //tex.add_x x_space
    (px,py) := (tex.x,tex.y)
    //lisave
    //draw_name
    //tex.set_x px
    //lirestore (0,0)
    //
    x := px
    (type_c != NULL).if {
      begin_path
      stroke_color (LOOK.none)
      stroke_width 3.0
      rect (x,py+asc_c-16) size (14,14)
      stroke
      y := py + asc_c - des_c
    } else {
      py := py - des_c + 5
      (x,y) := header_box Self to (tex.x,py) xmax 0
      xxmax := x
      (x,y) := header_box Self to (tex.x,py) xmax x
    }
    //
    
    y-tex.y        
  )
  
  - xxmax:REAL_32
  - header_box p:PROTO to (x,y:REAL_32) xmax xmx:REAL_32 :(REAL_32,REAL_32) <-
  ( + yb,xm,xe,hc,xc,yc,xb,de,a,d:REAL_32
    + t:TYPE
    + to:TPRO
    + nf:BOOLEAN
    
    hc := asc_c-des_c
    yb := y
    p.slot.foreach { s:SLOT
      ((s.clonable) && {s.ttok != NULL} && {s.type != NULL}).if {        
        de := 0
        (xmx <= 0).if {          
          //xb := x+5+16; //DCHAR.clone TRUE exp (s.expanded) to (x+5,yb+5+asc_c)
          xb := LOOK.clone TRUE exp FALSE to (x+5,yb+5+asc_c)
          to ?= s.type
          xe := xb; //+x_space*0.5
          fill_color (LOOK.cols.at (LOOK.slot))
          STRING.tmp { tmp:STRING_BUFFER
            tmp.copy (s.name_id)
            tmp.replace_all '\0' with ' '; // BSBS: Utile maintenant ??
            xe := text (xe+x_space,yb+5+asc_c) msg tmp
          }
          ((to != NULL) && {(to.is (TYPE.expanded)) || {to.proto.type_c != NULL}}).if {
            fill_color (LOOK.none)
            xe := text (xe,yb+5+asc_c) msg ":"
            //save
            (xe,a,d) := s.draw_type_extern_to (xe,yb+5+asc_c)
            //restore
          }
        } else {
          (nf).if {
            begin_path
            stroke_width 1.0
            stroke_color (LOOK.header)
            line (x,yb) to (xmx,yb)
            stroke
          }
        }
        nf := TRUE
        t := s.type
        t.foreach_until { tt:TONE
          to ?= tt
          (to != NULL).if {
            ((to.is (TYPE.expanded)) && {to.proto.type_c = NULL}).if {
              (xb,yb) := header_box (to.proto) to (x + 10,yb+hc+10) xmax (xmx-10)
              xm := xm.max xb.max xe
            } else {
              de := 24
              (xmx > 0).if {
                (xc,yc) := (xmx - 22 + 8,yb+5+asc_c-7)
                ((to.proto = NULL) || {to.proto.type_c != NULL}).if {
                  begin_path
                  stroke_color (LOOK.none)
                  stroke_width 3.0
                  rect (xc-7,yc-7) size (14,14)
                  stroke
                } else {
                  begin_path
                  fill_color (LOOK.none)
                  stroke_color (LOOK.none)
                  circle (xc,yc) radius 8
                  fill
                  begin_path
                  stroke_width 3.0
                  line (xc,yc) to (xxmax+20,yc)
                  xc := xxmax + 20
                  line (xc,yc) to (xc-5,yc-5)
                  line (xc,yc) to (xc-5,yc+5)
                  stroke
                  s.draw_type_extern_to (xxmax+27,yc-14+asc_c)
                }
              }
              yb := yb + hc + 10
            }
            //yb := yb + hc + 10
          }
          xm := xm.max (xe+de)
          FALSE
        }
      }
    }
    (xmx > 10).if {
      begin_path
      stroke_color (LOOK.header)
      stroke_width 3.0
      rect (x,y) to (xmx,yb) radius 4
      stroke
    }
    xm+10,yb+10
  )
  
Public
  
  - draw_to (x,y:REAL_32) :(REAL_32,REAL_32,REAL_32) <-
  ( + rx,ra,rd:REAL_32
    + mute:BOOLEAN
    mute := TOK_ITM.txt_buf = src
    tex.push (0,0)
    tex.set_xy (x,y-asc_c)
    // Load environnement    
    tok_cur := 0
    begin 0
    styi := 0
    pos_i := tname.db
    // Draw
    
    (mute).if {
      DIV.mute { tname.draw; }
    } else {
      DIV.new.drw {
        DIV.mute { tname.draw; }
      } act {d:DIV
        PAGE.cur_pg.set_buffer src
      }
    }
    (rx,ra,rd) := (tex.x,tex.asc,tex.des)
    end_line
    // Restore Old environnement
    begin (Old pt_b)
    TOK_ITM.set_parent_tok_drw (Old TOK_ITM.parent_t_drw)
    styi := Old styi
    tok_cur := Old tok_cur
    pos_i := Old pos_i
    //
    tex.pop
    rx,ra,rd
  )
    
  - draw_name <-
  // BSBS doublon plus ou moins avec draw_to
  (
    // Load environnement    
    tok_cur := 0
    begin 0
    styi := 0
    pos_i := tname.db
    DIV.mute { tname.draw; }
    // Restore Old environnement
    begin (Old pt_b)
    TOK_ITM.set_parent_tok_drw (Old TOK_ITM.parent_t_drw)
    styi := Old styi
    tok_cur := Old tok_cur
    pos_i := Old pos_i
  )
  
Public
  
  //
  // Commands
  //
  
  - search s:STRING base b:INTEGER at idx:INTEGER :INTEGER <-
  [ ? {idx.in_range b to (b+di)}; ]
  ( + r:INTEGER
    r := -1
    r := tname.search s base b at idx
    ((r = -1) && {rmk_b < rmk_e} && {idx < rmk_e}).if {
      r := search s range (rmk_b.max idx) to rmk_e
      (r != -1).if { open_win := '1'; }
    }
    (r = -1).if {
      (type_c != NULL).if { r := type_c.search s base b at idx; }
      ((r = -1) && {default != NULL}).if { r := default.search s base b at idx; }
      ((r = -1) && {export != NULL}).if  { r := export.search s base b at idx;  }
      ((r = -1) && {import != NULL}).if  { r := import.search s base b at idx;  }
      ((r = -1) && {lip != NULL}).if     { r := lip.search s base b at idx;     }
      ((r = -1) && {extern_c != NULL}).if { r := extern_c.search s base b at idx; }
      (r != -1).if { open_win := '2'; }
    }
    r
  )
  
  - search_back s:STRING base b:INTEGER at idx:INTEGER :INTEGER <-
  [ ? {idx.in_range b to (b+di)}; ]
  ( + r:INTEGER
    r := -1
    (extern_c != NULL).if              { r := extern_c.search_back s base b at idx;}
    ((r = -1) && {lip     != NULL}).if { r := lip.search_back s base b at idx;     }
    ((r = -1) && {import  != NULL}).if { r := import.search_back s base b at idx;  }
    ((r = -1) && {export  != NULL}).if { r := export.search_back s base b at idx;  }
    ((r = -1) && {default != NULL}).if { r := default.search_back s base b at idx; }
    ((r = -1) && {type_c  != NULL}).if { r := type_c.search_back s base b at idx;  }
    (r != -1).if { open_win := '2'; }
    ((r = -1) && {rmk_b < rmk_e} && {idx >= rmk_b}).if {      
      r := search_back s range (rmk_e.min idx) downto rmk_b
      (r != -1).if { open_win := '1'; }
    }
    (r = -1).if { r := tname.search_back s base b at idx; }
    r
  )

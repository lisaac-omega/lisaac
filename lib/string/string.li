Header
  + name := STRING;
  /*Generic prototype for STRING_BUFFER and STRING_ALIAS*/
  - export  := STRING_BUFFER;
  - external := `
#include <errno.h>
#include <string.h>  
  `;
  
Inherit
  - parent_clone:CLONE := CLONE

STRING, FILE_SYSTEM, INTN_BIG, ℤ_BIG, ℤ, FILE_UTILS, INTEGER_64, UINTEGER_64

  + storage:NATIVE_ARRAY CHARACTER
  // Collection containing characters
  
Private
  - stack_tmp:Expanded ARRAY STRING_BUFFER
  
Public
  - new_tmp:STRING_BUFFER <-
  ( + result:STRING_BUFFER
    (stack_tmp.is_empty).if {
      result := STRING_BUFFER.create 512
    } else {
      result := stack_tmp.pop
      result.clear
    }
    result
  )
  
  - free_tmp:STRING_BUFFER <- ( stack_tmp.add_last (STRING_BUFFER.cast Self); NULL)
  
  - tmp b:{STRING_BUFFER;} <-
  ( + t:STRING_BUFFER
    t := new_tmp
    b.value t
    stack_tmp.add_last t
  )
  
  - tmp2 b:{(STRING_BUFFER,STRING_BUFFER);} <-
  ( + t1,t2:STRING_BUFFER
    (t1,t2) := (new_tmp,new_tmp)
    b.value (t1,t2)
    stack_tmp.add_last t2; stack_tmp.add_last t1
  )
  
  // BSBS: Pb de priority, a revoir dans la new version.
  - Self:SELF '+=' other:STRING :STRING_BUFFER <- STRING_BUFFER.crash
  - Self:SELF '|' c:CHARACTER :STRING_BUFFER <- STRING_BUFFER.crash
  
  - count:INTEGER <- upper + 1

  - lower:INTEGER; // Always 0

  + upper:INTEGER := -1

  - capacity:INTEGER <- count
  // size
  
  
  // Access.
  
  - at index:INTEGER :CHARACTER <- item index
  
  - item index:INTEGER :CHARACTER <-
  // Character at position `index'.
  // * Require: index is valid
  [
    -? {valid_index index}
  ]
  (
    storage.at index
  )

  // Switch case :

  - when val:STRING then block:{} :STRING <-
  // When `Self' equal `val', execute `block'
  (
    (Self == val).if block
    Self
  )

  - when value1:STRING or value2:STRING then block:{} :STRING <-
  // When `Self' equal `value1' or `value2', execute `block'
  (
    ((Self == value1) || {Self == value2}).if block
    Self
  )

  - case val:SELF then block:{} :SELF <-
  // * See: `when_then'
  ( + result :SELF

    (Self == val).if {
      block.value
      result := SELF
    } else {
      result := Self
    }
    result
  )

  - case_if test:{BOOLEAN} then block:{} :STRING <-
  // If `test' is true then `block'
  ( + result :STRING

    ((Self != STRING) && test).if {
      block.value
      result := STRING
    } else {
      result := Self
    }
    result
  )

  - default block:{} <-
  // otherwise, execute `block'
  (
    (Self != STRING).if block
  )
  
  - foreach do:{CHARACTER; } <-
  (
    0.to upper do { i:INTEGER
      do.value (item i)
    }
  )
  
  // Testing.

  - valid_index index:INTEGER :BOOLEAN <-
  // True when `index' is valid (i.e., inside actual bounds).
  ( index.in_range lower to upper )

  - is_empty : BOOLEAN <- count = 0


  - hash_code: INTEGER <- hash_code_intern
  // Return a hashcode
  
  - Self:SELF '<' other:SELF :BOOLEAN <- Self ~< other
  
  - Self:SELF '>' other:SELF :BOOLEAN <- other < Self
  
  - Self:SELF '~>' other:STRING :BOOLEAN <- other ~< Self

  - Self:SELF '~<' other:STRING :BOOLEAN <-
  // Is Current less than `other' ?
  ( + i: INTEGER
    + result: BOOLEAN

    {(i > upper) || {i > other.upper} || {item i != other.item i}}.until_do {
      i := i + 1
    }
    (i > upper).if {
      result := other.upper >= i
    } else {
      (i <= other.upper).if {
        result := item i < other.item i
      }
    }
    result
  )

  - Self:SELF '!<' other:STRING :BOOLEAN <-
  // Is Current less than `other' ? But, the `upper' to `lower' comparaison
  ( + i1,i2: INTEGER
    + result:BOOLEAN

    i1 := upper
    i2 := other.upper
    {(i1 < lower) || {i2 < other.lower} || {item i1 != other.item i2}}.until_do {
      i1 := i1 - 1
      i2 := i2 - 1
    }
    (i1 < lower).if {
      result := i2 >= other.lower
    } else {
      (i2 >= other.lower).if {
        result := item i1 < other.item i2
      }
    }
    result
  )

  - compare other:STRING :INTEGER <-
  // Compare alphabetically `Self' to `other'
  ( + i: INTEGER
    + result:INTEGER
   
    {(i > upper) || {i > other.upper} || {item i != other.item i}}.until_do {
      i := i + 1
    }
    (i > upper).if {
      (i > other.upper).if {
        result := 0
      } else {
        result := -1
      }
    } else {
      (i > other.upper).if {
        result := 1
      } else {
        (item i < other.item i).if {
          result := -1
        } else {
          result := 1
        }
      }
    }

    result
  )

  - same_as other:STRING :BOOLEAN <-
  // Case insensitive `=='.
  ( + s1, s2:NATIVE_ARRAY(CHARACTER)
    + i:INTEGER
    + result:BOOLEAN
    ? {other != NULL}

    i := upper
    (i = other.upper).if {
      (storage.fast_memcmp (other.storage) until i).if {
        result:=TRUE
      } else {        
        s1 := storage
        s2 := other.storage
        result:=TRUE
        {(i!=0) && {result}}.while_do {
          result:=s1.item i.same_as (s2.item i)
          i:=i-1
        }
      }
    }
    result
  )
  
  - Self:SELF '==' Left 40 other:STRING :BOOLEAN <-
  // Has Current the same text as `other' ?
  ( + result:BOOLEAN
    (Self = other).if {
      result := TRUE
    }.elseif {other != NULL} then {      
      (upper = other.upper).if {
        (upper = -1).if {
          result := TRUE
        } else {
          result:=storage.fast_memcmp (other.storage) until upper
        }
      }
    }
    result
  )
  
  - Self:SELF '!==' Left 40 other:STRING :BOOLEAN <- ! (Self == other)
  
  - index_of ch:CHARACTER since start_index:INTEGER :INTEGER <-
  // Index of first occurrence of `c' at or after `start_index',
  // result = upper + 1, if none.
  ( + result:INTEGER
    ? { start_index.in_range 0 to count}

    result := start_index

    {(result > upper) || {ch = item result}}.until_do {
      result := result + 1
    }

    result
  )

  - last_index_of ch:CHARACTER since start_index:INTEGER :INTEGER <-
  // Index of first occurrence of `c' at or before `start_index',
  // -1 if none.
  ( + result:INTEGER
    ? {start_index.in_range (-1) to upper}

    result := start_index

    {(result < lower) || {ch = item result}}.until_do {
      result := result - 1
    }

    ? {(result != -1) ->> {item result = ch}}
    result
  )

  - fast_index_of ch:CHARACTER :INTEGER <-
  // Gives the index of the first occurrence `ch' or
  // upper+1 if none.
  (+ result:INTEGER
    (upper >= 0).if {
      result := storage.fast_index_of (ch,0) until upper
      ? {(result != upper + 1) ->> {item result = ch}}
    }
    result
  )

  - index_of ch:CHARACTER :INTEGER <-
  // Gives the index of the first occurrence of 'ch' or
  // 0 if none.
  (
    fast_index_of ch
  )

  - first_index_of c:CHARACTER :INTEGER <-
  // Index of first occurrence of `c' at index 1 or after index 1.
  (
    fast_index_of c
  )

  - fast_last_index_of ch:CHARACTER :INTEGER <-
  // Gives the index of the last occurrence `ch' or
  // -1 if none.
  ( + result:INTEGER
    result := storage.fast_reverse_index_of ch from upper
    result    
  )
  [ ? {(Result != -1) ->> {item Result = ch}}; ]

  - last_index_of c:CHARACTER :INTEGER <-
  // Index of last occurrence of `c' at index upper or before index upper.
  (
    fast_last_index_of c
  )
  
  - last_path_separator:INTEGER <-
  ( + i:INTEGER
    i := upper
    {(i >= 0) && {at i != '/'} && {at i != '\\'}}.while_do { i := i - 1; }
    i
  )

  - first_diff other:STRING :INTEGER <-
  // First difference index with `other'.
  // if `other' is equal `Self', return `upper' + 1
  [ -? {other != NULL}; ]
  ( + result:INTEGER

    (Self = other).if {
      result := upper + 1
    } else {
      result := lower
      {
        (result <= upper) &&
        {result <= other.upper} &&
        {item result = other.item result}
      }.while_do {
        result := result + 1
      }
    }
    result
  )
   
  - first_diff other:STRING from start:INTEGER :INTEGER <-
  // First difference index with `other'.
  // if `other' is equal `Self', return `upper' + 1
  [ -? {other != NULL}; ]
  (
    first_diff_from 0 with other from start
  )
  
  - first_diff_from i:INTEGER with other:STRING from start:INTEGER :INTEGER <-
  // First difference index with `other'.
  // if `other' is equal `Self', return `upper' + 1
  [ -? {other != NULL}; ]
  ( + result,j:INTEGER

    (Self = other).if {
      result := upper + 1
    } else {
      result := i
      j := start
      {
        (result <= upper) && 
        {j <= other.upper} && 
        {item result = other.item j}
      }.while_do {
        result := result + 1
        j := j + 1
      }
    }
    result
  )
    
  - reverse_first_difference_index other:STRING :(INTEGER,INTEGER) <-
  // First result: index in Self, Second result: index in other.
  ( + i,io:INTEGER
    i := upper
    io := other.upper
    {(i >= 0) && {io >= 0} && {item i = other.item io}}.while_do {
      i := i - 1
      io := io - 1
    }
    i,io
  )

  - has ch:CHARACTER :BOOLEAN <- storage.fast_has ch until upper
  // True if `ch' is in the STRING_BUFFER.

  - has_substring other:STRING :BOOLEAN <-
  // True if `other' is in the STRING_BUFFER.
  ( first_substring_index other != -1 )
  
  - submatch other:STRING separator sep:CHARACTER :INTEGER <-
  // Ex.: "home.ben.java.lang.string".submatch "string.length" separator '.'  
  //                                ^          ^      R=6
  // else R=0
  [ ? {! other.is_empty}; ? {! is_empty}; ] 
  ( + io,is:INTEGER
    + result,cur_is,last_sep_o:INTEGER
    {(is <= upper) && {result != other.count}}.while_do {      
      cur_is := is
      io := 0
      {(cur_is <= upper) && {io <= other.upper} && {item cur_is = other.item io}}.while_do {
        (other.item io = sep).if { last_sep_o := io; }
        cur_is := cur_is + 1
        io := io + 1
      }
      (cur_is > upper).if { 
        ((io > other.upper) || {other.item io = sep}).if { 
          result := io
        } else { 
          result := result.max last_sep_o
        }
      }
      {(is <= upper) && {item is != sep}}.while_do {
        is := is + 1
      }
      is := is + 1
    }
    result
  )
  
  - occurrences c:CHARACTER :INTEGER <-
  // Number of times character `c' appears in the string.
  (
    occurrences c until upper
  )
  
  - occurrences c:CHARACTER until up:INTEGER :INTEGER <-
  (
    storage.fast_occurrences c until up
  )
  
  - occurrences c:CHARACTER from lo:INTEGER to up:INTEGER :INTEGER <-
  (
    storage.slice_fast_occurrences c from lo until up
  )

  - has_suffix s:STRING :BOOLEAN <-
  // True if suffix of `Current' is `s'.
  (
    + result:BOOLEAN
    + i1,i2:INTEGER

    ? { s != NULL }

    (s.upper <= upper).if {
      i1 := upper - s.upper
      i2 := 0
      { (i1 > upper) || { i2 > s.upper} || { item i1 != s.item i2}}.until_do {
        i1 := i1 + 1
        i2 := i2 + 1
      }
      result := i1 > upper
    }

    result
  )

  - has_prefix p:STRING :BOOLEAN <-
  // True if prefix of `Current' is `p'.
  [ ? { p != NULL }; ]
  ( + result:BOOLEAN
    + i:INTEGER
    (p.upper <= upper).if {
      i := p.upper
      {(i = -1) || { item i != p.item i}}.until_do {
        i := i - 1
      }
      result := i = -1
    }
    result
  )

  // Testing and Conversion:
  
  - is_uppercase_identifier:BOOLEAN <-
  // 'A'-'Z' {'A'-'Z' | '0'-'9' | '_'}
  ( + i:INTEGER
    + c:CHARACTER
    {(i <= upper) && {(c := item i).is_upper || {c.is_digit} || {c = '_'}}}.while_do {
      i := i + 1
    }
    i > upper
  )
  
  - is_boolean:BOOLEAN <-
  // does self represent a BOOLEAN?
  // valid BOOLEANS are "TRUE" and "FALSE".
  (
    (Self == "TRUE") || { Self == "FALSE"}
  )

  - to_boolean:BOOLEAN <-
  // Boolean value
  // "true" yields true, "false" yields false (what a surprise).
  (
    ?{ is_boolean }
    Self == "TRUE"
  )

  - is_bit:BOOLEAN <-
  // True when the contents is a sequence of bits (i.e., mixed
  // characters `0' and characters `1').
  ( + i:INTEGER
    + result:BOOLEAN
    i := upper
    result := TRUE
    { (! result) || { i = -1}}.until_do {
      result := item i.is_bit
      i := i - 1
    }
    ? {result = (count = occurrences '0' + occurrences '1')}
    result
  )

  - is_integer:BOOLEAN <-
  // Does self represent an INTEGER?
  // `Result' is true if and only if the following two conditions hold:
  // 1. In the following BNF grammar, the value of self can be
  // produced by "Integer_literal", if leading and trailing
  // separators are ignored:
  // Integer_literal = ['+'|'-'] Digit { Digit }
  // Digit           = '0' .. "9"
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type INTEGER.
  ( + result:BOOLEAN
    + cc: CHARACTER
    + i:INTEGER
    
    (is_empty).if_false {      
      cc := item 0
      ((cc = '-') || {cc = '+'}).if {
        i := 1
      }
      (i <= upper).if {
        {(i <= upper) && {item i.is_digit}}.while_do {
          i := i + 1
        }
        result := i > upper
      }
    }
    result
  )
  
  - is_integer_64:BOOLEAN <-
  // Does self represent an INTEGER_64?
  // `Result' is true if and only if the following two conditions hold:
  // 1. In the following BNF grammar, the value of self can be
  // produced by "Integer_literal", if leading and trailing
  // separators are ignored:
  // Integer_literal = [Sign] Integer
  // Sign            = "+" | "-"
  // Integer         = Digit | Digit Integer
  // Digit           = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type INTEGER_64.
  (
    + i, state: INTEGER
    + value:INTEGER_64
    + negative: BOOLEAN
    + result:BOOLEAN
    + cc: CHARACTER

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.
    // state 4: error.

    i := 0
    { (state = 4) || {i > upper}}.until_do {
      cc := item i
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        }.elseif {cc.is_digit} then {
          value := cc.decimal_value
          state := 2
        } else {
          state := 4
        }
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value := cc.decimal_value
          negative.if {
            value := - value
          }
          state := 2
        } else {
          state := 4
        }
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          negative.if {
            value := value * 10 - cc.decimal_value
          } else {
            value := value * 10 + cc.decimal_value
          }
          // over/underflow check here
          ((negative && {value > 0}) || { ! negative && {value < 0}}).if {
            state := 4
          }
        }.elseif {cc.is_separator} then {
          state := 3
        } else {
          state := 4
        }
      }.elseif { state = 3 } then {
        cc.is_separator.if {
        } else {
          state := 4
        }
      }
      i := i + 1
    }
    ( (state != 0) && { state != 4}).if {
      result := TRUE
    }

    result
  )
    
  - to_integer:INTEGER <-
  // self must look like an INTEGER.
  (
    + i, state:INTEGER
    + cc: CHARACTER
    + negative: BOOLEAN
    + result:INTEGER

    ? { is_integer }
    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.

    i := 0

    { i > upper}.until_do {
      cc := item i

      (state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        } else { // cc.is_digit
          result := cc.decimal_value
          state := 2
        }
      }.elseif { state = 1 } then {
        // cc.is_digit
        result := cc.decimal_value
        negative.if {
          result := - result
        }
        state := 2
      }.elseif { state = 2} then {
        cc.is_digit.if {
          negative.if {
            result := 10 * result - cc.decimal_value
          } else {
            result := 10 * result + cc.decimal_value
          }
        } else { // cc.is_separator
          state := 3
        }
      }.elseif { state = 3 } then {
        // cc.is_separator
        i := upper; // terminate the loop
      }

      i := i + 1
    }

    result
  )
  
  - to_real_32:REAL_32 <- to_real_64.to_real_32
  
  - to_real_64:REAL_64 <-
  ( + ok:BOOLEAN
    + v:REAL_64
    (ok,v) := to_real_64_at 0
    ? {ok}
    v
  )
  
  - to_real_64_at i:INTEGER :(BOOLEAN, REAL_64) <-  
  ( + c,n:CHARACTER
    + e0,e1,cu:INTEGER
    + neg,f,err:BOOLEAN
    + value:REAL_64
    cu := i
    (cu <= upper).if {
      (((c := at cu).is_digit) || {(neg := c = '-') && {cu < upper} && {(c := at (cu+1)).is_digit}}).if {        
        value := c.to_digit; cu := cu + 1 + neg.to_integer
        {(cu <= upper) && {((c := at cu).is_digit) || {c = '_'} || {c = '\''} || {c = '.'}}}.while_do {
          (c.is_digit).if { value := value * 10 + c.to_digit; e0 := e0 + f.to_integer; }
          (c = '.').if { err := f; f := TRUE; }
          cu := cu + 1
        }
        (!err).if {
          (f && {e0 = 0}).if { cu := cu - 1; }
          (cu <= upper).if {
            ((c := at cu).to_upper = 'E').if {
              cu := cu + 1
              (cu <= upper).if {
                (((n := at cu) = '-') || {n = '+'}).if { cu := cu + 1; }
                {(cu <= upper) && {(c := at cu).is_digit}}.while_do { e1 := e1 * 10 + c.to_digit; cu := cu + 1; }
                (n = '-').if { e1 := -e1; }
              }
            }
          }
          e1 := e1 - e0
          (e1 != 0).if { value := value * 10.0.pow e1; }
          (neg).if { value := -value; }
        }
      }
    }
    (i != cu) && {!err}, value
  )
  
  - to_integer_64:INTEGER_64 <-
  // self must look like an INTEGER.
  ( + i, state:INTEGER
    + cc: CHARACTER
    + negative: BOOLEAN
    + result:INTEGER_64

    ? { is_integer_64 }
    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.

    i := 0
    {i > upper}.until_do {
      cc := item i

      (state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        } else { // cc.is_digit
          result := cc.decimal_value
          state := 2
        }
      }.elseif { state = 1 } then {
        // cc.is_digit
        result := cc.decimal_value
        negative.if {
          result := - result
        }
        state := 2
      }.elseif { state = 2} then {
        cc.is_digit.if {
          negative.if {
            result := result * 10 - cc.decimal_value
          } else {
            result := result * 10 + cc.decimal_value
          }
        } else { // cc.is_separator
          state := 3
        }
      }.elseif { state = 3 } then {
        // cc.is_separator
        i := upper; // terminate the loop
      }
      i := i + 1
    }
    result
  )
  
  - is_hexadecimal:BOOLEAN <-
  ( + j:INTEGER
    + result:BOOLEAN
    (is_empty).if_false {
      j := lower
      {(j > upper) || {! item j.is_hexadecimal_digit}}.until_do {
        j:=j+1
      }
      result := j > upper
    }
    result
  )

  - to_hexadecimal:UINTEGER_64 <-
  ( + result:UINTEGER_64
    ? {is_hexadecimal}
    lower.to upper do { j:INTEGER
      result := (result << 4) | item j.hexadecimal_value
    }
    result
  )

  - is_octal :BOOLEAN <-
  ( + result:BOOLEAN
    + j:INTEGER
    (is_empty).if_false {
      j := lower
      {(j > upper) || {! item j.is_octal_digit}}.until_do {
        j:=j+1
      }
      result:= j > upper
    }
    result
  )

  - to_octal:UINTEGER_64 <-
  ( + result:UINTEGER_64
    ? {is_octal}

    lower.to upper do { j:INTEGER
      result := (result << 3) | item j.octal_value
    }
    result
  )

  - is_binary:BOOLEAN <-
  ( + result:BOOLEAN
    + j:INTEGER

    (is_empty).if_false {
      j := lower
      { (j > upper) || {! item j.is_binary_digit} }.until_do {
        j := j + 1
      }

      result := j > upper
    }

    result
  )

  - to_binary :UINTEGER_64 <-
  ( + result:UINTEGER_64
    ? {is_bit}

    lower.to upper do { j:INTEGER
      result := result << 1
      (item j = '1').if {
        result := result | 1
      }
    }
    result
  )

  - is_real_16_16:BOOLEAN <-
  // Does self represent an REAl_16_16 ?
  // `Result' is true if and only if the following two conditions hold:
  // 1. In the following BNF grammar, the value of self can be
  // produced by "real_literal", if leading and trailing
  // separators are ignored:
  // Real_literal = [Sign] Integer [Point Integer]
  // Sign            = "+" | "-"
  // Point           = "."
  // Integer         = Digit | Digit Integer
  // Digit           = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type REAL_16_16.
  (
    + i, state, value_int: INTEGER
    + value:REAL_16_16
    + negative: BOOLEAN
    + result:BOOLEAN
    + cc: CHARACTER
    + d:INTEGER

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number before the point
    // state 3: in the number after the point
    // state 4: after the number.
    // state 5: error.

    i := 0
    d := 1

    { (state = 5) || {i > upper}}.until_do {
      cc := item i
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        }.elseif {cc.is_digit} then {
          value_int := cc.decimal_value
          state := 2
        } else {
          state := 5
        }
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value_int := cc.decimal_value
          state := 2
        } else {
          state := 5
        }
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          value_int := 10 * value_int + cc.decimal_value
          (value_int < 0).if {
            state := 5
          }
        }.elseif { cc = '.' } then {
          state := 3
          value := value_int.to_real_16_16
        }.elseif {cc.is_separator} then {
          state := 4
        } else {
          state := 5
        }
      }.elseif { state = 3 } then {
        cc.is_digit.if {
          d := d * 10
          value := value + (cc.decimal_value.to_real_16_16) /# d
        }.elseif {cc.is_separator} then {
          state := 4
        } else {
          state := 5
        }
      }.elseif { state = 4 } then {
        cc.is_separator.if {
        } else {
          state := 5
        }
      }

      i := i + 1
    }
    negative.if {
      value := - value
    }
    ( (state != 0) && { state != 5}).if {
      result := TRUE
    }

    result
  )
      
  - to_real_16_16:REAL_16_16 <-
  (
    + i, state, value_int: INTEGER
    + value:REAL_16_16
    + negative: BOOLEAN
    + cc: CHARACTER
    + d:INTEGER

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number before the point
    // state 3: in the number after the point
    // state 4: after the number.

    i := 0
    d := 1

    {i > upper}.until_do {
      cc := item i
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        }.elseif {cc.is_digit} then {
          value_int := cc.decimal_value
          state := 2
        }
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value_int := cc.decimal_value
          state := 2
        }
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          value_int := value_int * 10 + cc.decimal_value
        }.elseif { cc = '.' } then {
          state := 3
          value := value_int.to_real_16_16
        } else {  // cc is separator
          value := value_int.to_real_16_16
          state := 4
        }
      }.elseif { state = 3 } then {
        cc.is_digit.if {
          d := d * 10
          value := value + (cc.decimal_value.to_real_16_16) /# d
        } else { // cc is separator
          state := 4
        }
      }.elseif { state = 4 } then {
        // cc is separator
        i := count;  // terminate the loop
      }

      i := i + 1
    }

    (state = 2).if {
      value := value_int.to_real_16_16
    }

    negative.if {
      value := - value
    }

    value
  )
  
  - at i:INTEGER utf8_in buf:STRING_BUFFER :INTEGER <-
  ( + n:UINTEGER_8
    + j:INTEGER
    buf.clear
    n := at i
    buf.add_last (n.to_character)
    ((n & 80h) != 0).if {
      j := i
      { j := j + 1
        buf.add_last (at j)
        n := n << 1
      }.do_until {(n & 40h) = 0}
    }
    buf.count
  )
    
  // Loop.
  
  - do_all do:{CHARACTER;} <-
  (
    0.to upper do { i:INTEGER
      do.value (item i)
    }
  )
  
  // Modification:

  - Self:SELF '+' other:STRING :STRING_BUFFER <-
  // Create a new STRING_BUFFER which is the concatenation of
  // `self' and `other'.
  [
    -? {other != NULL}
  ]
  ( + result:STRING_BUFFER
    result:=STRING_BUFFER.create (count + other.count)
    result.append Self
    result.append other
    result
  )
  [
    +? {Result.count = Old count + other.count}
  ]
  
  
  - as_lower:STRING_BUFFER <-
  // New object with all letters in lower case.
  (
    + result:STRING_BUFFER
    result := STRING_BUFFER.create capacity
    result.copy Self
    result.to_lower
    result
  )

  - as_upper:STRING_BUFFER <-
  // New object with all letters in upper case.
  (
    + result:STRING_BUFFER
    result := STRING_BUFFER.create capacity
    result.copy Self
    result.to_upper
    result
  )

  // Other features:

  - first:CHARACTER <-
  // Access to the very `first' character.
  [ ? {! is_empty}; ]
  ( storage.at 0 )
  [ /*? { result == item lower};*/ ]
  
  - second:CHARACTER <-
  // Access to the very `second' character.
  [ ? {upper > 0}; ]
  ( storage.at 1 )
  [ /*? { result == item (lower+1)};*/ ]

  - last:CHARACTER <-
  // Access to the very `last' character.
  (
    + result:CHARACTER
    ? {! is_empty}
    result := storage.at upper
    ? { result = item upper}
    result
  )
  
  - substring start_index:INTEGER to end_index:INTEGER in str:STRING_BUFFER <-
  // New string consisting of items [`start_index'.. `end_index'].
  [
    -? { start_index >= 0 }
    -? { end_index <= upper }
    -? { start_index <= end_index + 1 }
  ]
  ( + c:INTEGER
    c := str.count + end_index - start_index + 1
    str.set_capacity c
    str.storage.slice_copy storage to (str.count) from start_index to end_index
    str.set_upper (c-1)
  )
  
  - substring start_index:INTEGER to end_index:INTEGER :STRING_BUFFER <-
  // New string consisting of items [`start_index'.. `end_index'].
  [
    -? { start_index >= 0 }
    -? { end_index <= upper }
    -? { start_index <= end_index + 1 }
  ]
  ( + c:INTEGER
    + result:STRING_BUFFER

    c := end_index - start_index + 1
    result := STRING_BUFFER.create c
    result.set_upper (c-1)
    result.storage.slice_copy storage to 0 from start_index to end_index
    result
  )
  [
    +? { Result.count = end_index - start_index + 1 }
  ]

  - substring_begin start:INTEGER to_begin end:INTEGER :STRING_BUFFER <-
  (
    substring start to end
  )

  - substring_begin start:INTEGER to_end end:INTEGER :STRING_BUFFER <-
  (
    substring start to (upper-end-1)
  )

  - substring_end start:INTEGER to_end end:INTEGER :STRING_BUFFER <-
  (
    substring (upper-start-1) to (upper-end-1)
  )
  
  - max_match from:INTEGER on other:STRING from start_other:INTEGER :(INTEGER,INTEGER) <-
  ( + result,i:INTEGER
    result := from
    i := start_other
    {(result <= upper) && {i <= other.upper} && 
    {item result = other.item i}}.while_do {
      result := result + 1
      i := i + 1
    }
    result, i
  )
  
  - substring_index (other:STRING,start_index:INTEGER) :INTEGER <-
  // Position of the first occurrence of `other' at or after 0
  // or -1 if none. // BSBS->DCDC renvoyer plutot upper+1 ce serait mieux...
  ( + i,s,result:INTEGER

    ? {! other.is_empty }
    ? { (start_index >=0) && { start_index <= upper + 1 }}
    result := -1
    s := start_index
    {(result != -1) || {(s + other.upper) > upper}}.until_do {
      i := 0
      {(i > other.upper) || {item (s + i) != other.item i}}.until_do {
        i := i + 1
      }
      (i > other.upper).if {
        result := s
      } else {
        s := s + 1
      }
    }
    result
  )

  - first_substring_index other:STRING :INTEGER <-
  // Position of the first occurrence of `other' at or after 0
  // or -1 if none.
  [
    ? {! other.is_empty }
  ]
  (
      substring_index (other,0)
  )

  // Splitting a STRING_BUFFER:
  
  /*
  - partition sep:STRING from start_index:INTEGER :(STRING_BUFFER, STRING_BUFFER, STRING_BUFFER) <-
  [
    -? {sep != NULL}
    -? {valid_index start_index}
  ]
  ( + i, j:INTEGER
    + head, sep, tail :STRING_BUFFER
    i := substring_index (sep, start_index)
    (i = 0).if {
      // Not found
      head := to_string_buffer
    } else {
      // Found
      j := i + sep.count
      (i > lower).if {
        head := substring lower to (i-1)
      }
      sep  := substring i to j
      (j < upper).if {
        tail := substring (j+1) to upper
      }
    }
    head, sep, tail
  )

  - partition sep:STRING :(STRING_BUFFER, STRING_BUFFER, STRING_BUFFER) <-
  (
    partition sep from lower
  )
*/
  - split_str sep:STRING :ARRAY(STRING_BUFFER) <-
  [
    -? {sep != NULL}
  ]
  ( + result:ARRAY(STRING_BUFFER)
    ( count > 0 ).if {
      split_buffer.clear
      split_str sep in split_buffer
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper)
        result.copy split_buffer
      }
    }

    result
  )
  [
    +? { (Result != NULL) ->> { ! Result.is_empty }}
  ]

  - split_str sep:STRING in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split_str' but result is appended in `words'.
  [
    -? {words != NULL}
    -? {sep != NULL}
  ]
  ( + i, j:INTEGER
    // i    first character of the next word
    // j-1  last character of the next word
    // j    first character of the next separator

    i := 0
    { j := substring_index(sep, i); j != -1 }.while_do {
      words.add_last (substring i to (j-1))
      i := j + sep.count
    }
    words.add_last (substring i to upper)
  )

  - split:ARRAY(STRING_BUFFER) <-
  // Split the string into an array of words. Uses `is_separator' of
  // CHARACTER to find words. Gives Void or a non empty array.
  (
    + result:ARRAY(STRING_BUFFER)
    (upper >= 0 ).if {
      split_buffer.clear
      split_in split_buffer
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper)
        result.copy split_buffer
      }
    }
    ? { (result != NULL) ->> { ! result.is_empty }}

    result
  )

  - split_in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split' but result is appended in `words'.
  (
    + state,old_count: INTEGER
    // state = 0: waiting next word.
    // state = 1: inside a new word.
    + c: CHARACTER

    ? { words != NULL}
    old_count := words.count
    (upper >= 0).if {
      lower.to upper do { i:INTEGER
        c := item i
        (state = 0).if {
          (! c.is_separator).if {
            string_buffer.clear
            string_buffer.append_character c
            state := 1
          }
        } else {
          (! c.is_separator).if {
            string_buffer.append_character c
          } else {
            words.add_last (string_buffer.twin)
            state := 0
          }
        }
      }
      ( state = 1).if {
        words.add_last (string_buffer.twin)
      }
    }

    ? { (words.count) >= old_count }
  )
  
  - is_upper:BOOLEAN <-
  // True, if all characters `is_upper' or '_' or digit.
  ( + i:INTEGER
    + c:CHARACTER
    i := lower
    {(i <= upper) && {
      (c := item i; c.is_upper) || {c = '_'} || {c.is_digit}}
    }.while_do { 
      i := i + 1
    }
    i > upper
  )
  
  - split_at sep:CHARACTER :ARRAY(STRING_BUFFER) <-
  // Split the string at characters `c' into an array of words.
  (
    + result:ARRAY(STRING_BUFFER)
    ( count > 0 ).if {
      split_buffer.clear
      split_at sep in split_buffer
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper)
        result.copy split_buffer
      }
    }

    result
  )
  [
    +? { (Result != NULL) ->> { ! Result.is_empty }}
  ]

  - split_at sep:CHARACTER in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split' but result is appended in `words'.
  (
    + state,old_count: INTEGER
    // state = 0: waiting next word.
    // state = 1: inside a new word.
    + c: CHARACTER

    ? { words != NULL}
    old_count := words.count
    (count > 0).if {
      0.to upper do { i:INTEGER
        c := item i
        (state = 0).if {
          (c != sep).if {
            string_buffer.clear
            string_buffer.append_character c
            state := 1
          }
        } else {
          (c != sep).if {
            string_buffer.append_character c
          } else {
            words.add_last (string_buffer.twin)
            state := 0
          }
        }
      }
      ( state = 1).if {
        words.add_last (string_buffer.twin)
      }
    }

    ? { (words.count) >= old_count }
  )

  - same_string other:STRING :BOOLEAN <-
  // Do self and other have the same character sequence?
  // Useful in proper descendants of STRING_BUFFER.
  (
    ? { other != NULL }
    Self == other.to_string_buffer
  )

  - to_string_buffer:STRING_BUFFER <-
  // New STRING_BUFFER having the same character sequence as self.
  // Useful in proper descendants of STRING_BUFFER.
  (
    STRING_BUFFER.create_from_string Self
  )
  
  - to_string_alias:STRING_ALIAS <-
  (
    abstract
    NULL
  )

  - to_string:STRING_ALIAS <- to_string_alias
      
Private
  
  - cur:ARRAY INTEGER := ARRAY INTEGER.create_with_capacity 64
  // Used for distances
  
Public
  
  // Distance.
  
  - lev o:STRING :INTEGER <-
  // Distance of Levenshtein
  ( + n,m,lastdiag,olddiag:INTEGER
    (n,m) := (count,o.count)
    cur.clear
    0.to n do { y:INTEGER; cur.add_last y; }
    1.to m do { x:INTEGER
      cur.at 0 put x
      lastdiag := x - 1
      1.to n do { y:INTEGER
        olddiag := cur.at y
        cur.at y put (
          (cur.at  y      + 1).min /* Delete */
 (cur.at (y - 1) + 1).min /* Insert */
         (lastdiag + (at (y - 1) = o.at (x - 1)).ok 0 or 1) // Subtitution
        )
        lastdiag := olddiag
      }
    }
    cur.last 
  )
  
  - dam o:STRING :INTEGER <-
  // Distance of Damerau
  ( + m,n,p,ci,pn:INTEGER
    + val:INTEGER
    (n,m) := (count,o.count)
    cur.clear
    0.to m do { j:INTEGER; cur.add_last j; }
    1.to n do { i:INTEGER
      ci := i
      p := cur.at 0
      cur.at 0 put i
      1.to m do { j:INTEGER
        pn := cur.at j
        val := p
        (
          (at (i-1) != o.at (j-1)) &&
          {(i <= 1) || {j <= 1} || {at (i-1) != o.at (j-2)} || {at (i-2) != o.at (j-1)}}
        ).if {
          val := 1 + p.min pn.min ci
        }
        ci := val
        p := pn
        cur.at j put val
      }
    }
    cur.last
  )
  
STRING

  - string_buffer:STRING_BUFFER := STRING_BUFFER.create 256; // Private, temporary once buffer.

  - split_buffer:ARRAY(STRING_BUFFER) := ARRAY(STRING_BUFFER).create_with_capacity 4 lower 1

Public
  
  - append_in b:STRING_BUFFER <-
  ( 0.to upper do { i:INTEGER
      b.add_last (at i)
    }
  )
  
  - print <-
  (    
    0.to upper do { i:INTEGER
      STDOUT.put_character (storage.at i)
    }
  )
  
  - print_error <-
  (    
    0.to upper do { i:INTEGER
      STDERR.put_character (storage.at i)
    }
  )
  
  - errno:STRING_ALIAS <- STRING_ALIAS.create (`strerror(errno)`:NATIVE_ARRAY CHARACTER)
  
  - to_external:NATIVE_ARRAY CHARACTER <-
  // Gives C access to the internal `storage' (may be dangerous).
  // To be compatible with C, a null character is added at the end
  // of the internal `storage'. This extra null character is not
  // part of the STRING_BUFFER.
  (
    abstract
    NULL
  )
  
STRING
  /*
  - hash_code_intern: INTEGER <-
  // Return a hashcode
  ( + result,up:INTEGER
    
    result := 7
    up := upper.min 32
    0.to up do { i:INTEGER
      result := result * 31 + item i.code
    }
    result & 07FFF_FFFFh
  )
  */

  - hash_code_intern: INTEGER <-
  // Return a hashcode
  ( + result,up:INTEGER
    
    up := upper.min 32
    0.to up do { i:INTEGER
      result := (result << 2) + item i.code
    }
    result & 07FFF_FFFFh
  )

 

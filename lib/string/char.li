Header
  + name := Expanded CHAR;
  /*
    32 bits UTF8 CHARacter.
    little endian storage.
  */
  - type    := `uint32_t`;
  - default := (`0`:CHAR);
  - export  := UINTEGER_32;

Insert
  - parent_print:PRINT := PRINT
  
USTRING
  - to_self i:UINTEGER_32 :SELF <- CAST UINTEGER_32 TO SELF.on i
    
Public
  - byte_count:INTEGER <-
  (
    ((31+8)-to_uinteger_32.clz) >> 3
  )
  [
    ? {Result.in_range 1 to 4}
  ]
  
  - to_uinteger_8:UINTEGER_8 <- CAST SELF TO UINTEGER_8.on Self
  
  - to_uinteger_32:UINTEGER_32 <- CAST SELF TO UINTEGER_32.on Self
  
  - from_alias s:STRING_ALIAS :CHAR <- // DCDC TEMPORARY... 
  ( + b1:UINTEGER_8
    + char:UINTEGER_32
    char := b1 := (s.item 0).to_uinteger_8
    (b1 >= 1000_0000b).if {
      UTILS.not_yet_implemented
    }
    to_self char
  )
  
Public
  - append_in b:STRING_BUFFER <-
  ( + in:NATIVE_ARRAY CHARACTER
    + sto:NATIVE_ARRAY UINTEGER_32
    b.prepare_space 4; // DCDC temporary... 1 not 4
    in := b.to_external
    sto := CAST (NATIVE_ARRAY CHARACTER) TO (NATIVE_ARRAY UINTEGER_32).on (in + b.upper + 1)
    sto.at 0 put to_uinteger_32
    b.set_upper (b.upper + byte_count)
  )
  
Public
  - is_ascii:BOOLEAN <- (to_uinteger_32 & 80h) = 0
  
  - ascii:UINTEGER_8 <-
  [
    ? {is_ascii}
  ]
  (
    to_uinteger_32.to_raw_uinteger_8
  )
  
Public
  
  - when value:CHAR then block:{} :CHAR <-
  (
    (Self=value).if block
    Self
  )

  - when value1:CHAR or value2:CHAR then block:{} :CHAR <-
  (
    ((Self = value1) || {Self = value2}).if block
    Self
  )

  - when first_value:CHAR to last_value:CHAR then block:{} :CHAR <-
  ( ? {first_value<=last_value}

    ((Self>=first_value) && {Self<=last_value}).if block
    Self
  )

  // Looping.

  - to limit_up:SELF do blc:{CHAR;} <-
  (
    (Self<=limit_up).if {
      blc.value Self
      (Self+1.to_character).to limit_up do blc
    }
  )

  - downto limit_down:SELF do blc:{CHAR;} <-
  (
    (Self>=limit_down).if {
      blc.value Self
      (Self-1.to_character).downto limit_down do blc
    }
  )

  - to limit_up:SELF by step:SELF do blc:{CHAR;} <-
  (
    (Self<=limit_up).if {
      blc.value Self
      (Self+step.to_character).to limit_up by step do blc
    }
  )

  - downto limit_down:SELF by step:SELF do blc:{CHAR;} <-
  (
    (Self>=limit_down).if {
      blc.value Self
      (Self-step.to_character).downto limit_down by step do blc
    }
  )

  // Binary operator :

  - Self:SELF '+' other:CHAR :CHAR <- (code+other.code).to_character

  - Self:SELF '-' other:CHAR :CHAR <- (code-other.code).to_character

  - Self:SELF '-!' other:CHAR :INTEGER   <- code - other.code

  - Self:SELF '+#' other:INTEGER :CHAR <- (code + other).to_character

  - Self:SELF '-#' other:INTEGER :CHAR <- (code - other).to_character

  - Self:SELF '<>' other:SELF :BOOLEAN <- ( code != other.code )
  // An other difference syntax (Pascal like)

  - Self:SELF '<' other:SELF :BOOLEAN <- ( code < other.code )
  // Comparison using `code'.

  - Self:SELF '<=' other:SELF :BOOLEAN <- ( code <= other.code )
  // Comparison using `code'.

  - Self:SELF '>' other:SELF :BOOLEAN <- ( code > other.code )
  // Comparison using `code'.

  - Self:SELF '>=' other:SELF :BOOLEAN <- ( code >= other.code )
  // Comparison using `code'.

  - decimal_value:INTEGER <-
  // Gives the value of a decimal digit.
  ( + result:INTEGER
    ? {is_digit}
    result := to_integer - 48
    ? {result.in_range 0 to 9}
    result
  )

  - binary_value:INTEGER <-
  // Gives the value of a binary digit.
  ( + result:INTEGER
    ? {is_binary_digit}
    result := code - 48
    ? {result.in_range 0 to 1}
    result
  )

  - octal_value:INTEGER <-
  // Gives the value of an octal digit.
  ( + result:INTEGER
    ? {is_octal_digit}
    result := code - 48
    ? {result.in_range 0 to 7}
    result
  )

  - hexadecimal_value:INTEGER <-
  // Gives the value of an hexadecimal digit.
  ( + result:INTEGER
    ? {is_hexadecimal_digit}
    (code < 'A'.code).if {
      result := code - 48
    }.elseif {code<'a'.code} then {
      result := code - 55
    } else {
      result := code - 87
    }
    ? {result.in_range 0 to 15}
    result
  )

  - same_as other:CHAR :BOOLEAN <-
  // Case insensitive comparison.
  // No difference between upper/lower case letters.
  ( + result:BOOLEAN
    (Self = other).if {
      result:=TRUE
    } else {
      code
      .when 65 to 90 then {
        result:=(code = (other.code - 32))
      }
      .when 97 to 122 then {
        result:=(code = (other.code + 32))
      }
      ? {result ->> {(to_lower = other) | (to_upper = other)}}
    }
    result
  )

  - to_upper:SELF <-
  // Conversion to the corresponding upper case.
  ( + result:SELF
    ((code < 97) || {code > 122}).if {
      result := Self
    } else {
      result := (code - 32).to_character
    }
    result
  )

  - to_lower:SELF <-
  // Conversion to the corresponding lower case.
  ( + result:SELF
    ((code < 65) || {code > 90}).if {
      result := Self
    } else {
      result := (code + 32).to_character
    }
    result
  )

  - is_letter:BOOLEAN <-
  // Is it a letter ('a' .. 'z' or 'A' .. 'Z') ?
  ( + result:BOOLEAN
    (Self >= 'a').if {
      result := (Self <= 'z')
    }.elseif {Self >= 'A'} then {
      result := (Self <= 'Z')
    }
    ? {result = (in_range 'A' to 'Z' | in_range 'a' to 'z')}
    result
  )

  - is_digit:BOOLEAN <-
  // Belongs to '0'..'9'.
  ( + result:BOOLEAN
    (Self >= '0').if {
      result := (Self <= '9')
    }
    ? {result = in_range '0' to '9'}
    result
  )

  - is_binary_digit:BOOLEAN <-
  // Belongs to '0'..'1'.
  ( + result:BOOLEAN
    result:= (Self = '0') || {Self = '1'}
    ? {result = in_range '0' to '1'}
    result
  )

  - is_octal_digit:BOOLEAN <-
  // Belongs to '0'..'7'.
  ( + result:BOOLEAN
    (Self >= '0').if {
      result := (Self <= '7')
    }
    ? {result = in_range '0' to '7'}
    result
  )

  - is_hexadecimal_digit:BOOLEAN <-
  // Is it one character of "0123456789abcdefABCDEF" ?
  ( + result:BOOLEAN
    (is_digit).if {
      result := TRUE
    }.elseif {Self >= 'a'} then {
      result := (Self <= 'f')
    }.elseif {Self >= 'A'} then {
      result := (Self <= 'F')
    }
    ? {result = ("0123456789abcdefABCDEF".has Self)}
    result
  )

  - is_lower:BOOLEAN <-
  // Is it some lowercase letter ('a'..'z')?
  ( + result:BOOLEAN
    (Self >= 'a').if {
      result:=(Self <= 'z')
    }
    result
  )

  - is_upper:BOOLEAN <-
  // Is it some uppercase letter ('A'..'Z')?
  ( + result:BOOLEAN
    (Self >= 'A').if {
      result:=(Self <= 'Z')
    }
    result
  )

  - is_separator:BOOLEAN <-
  // True when character is a separator (' ', '\t', '\n', '\r', '\0', '\f', '\v')?
  (
    (Self= ' ') || {Self = '\t'} || {Self='\n'} ||
    {Self='\r'} || {Self = '\0'} || {Self='\f'} || {Self='\v'}
  )

  - is_letter_or_digit:BOOLEAN <-
  // Is it a letter (see `is_letter') or a digit (see `is_digit') ?
  ( + result:BOOLEAN
    result := (is_letter || {is_digit})
    ? {result = (is_letter | is_digit)}
    result
  )

  - is_identifier:BOOLEAN <-
  // Is it a letter or a digit or '_' ?
  (
    (is_letter_or_digit) || {Self = '_'}
  )

  // Conversions:

  - to_hexadecimal:STRING_BUFFER <-
  // Create a new STRING_BUFFER giving the `code' in hexadecimal.
  // For example :
  //    (255).to_character.to_hexadecimal gives "FF".
  // Note: see `to_hexadecimal_in' to save memory.
  ( + result:STRING_BUFFER
    result := STRING_BUFFER.make 2
    to_hexadecimal_in result
    ? {result.count = 2}
    result
  )

  - to_hexadecimal_in str:STRING_BUFFER <-
  // Append the equivalent of `to_hexadecimal' at the end of
  // `str'. Thus you can save memory because no other
  // STRING_BUFFER is allocate for the job.
  ( + c, old_count:INTEGER

    old_count:=str.count
    c := code >> 4
    (c<10).if {
      str.extend (('0'.code + c).to_character)
    } else {
      str.extend (('A'.code - 10 + c).to_character)
    }
    c := code & 00001111b
    (c<10).if {
      str.extend (('0'.code + c).to_character)
    } else {
      str.extend (('A'.code - 10 + c).to_character)
    }
    ? {str.count = (2 + old_count)}
  )

  // Miscellaneous:

  - is_alpha:BOOLEAN <-
  // See `is_letter' (yes this is just a call to `is_letter').
  // Isn't `is_letter' better English ;-)
  ( + result:BOOLEAN
    result := is_letter
    ? {result = is_letter}
    result
  )

  // Hashing :

  - hash_code: INTEGER <- code

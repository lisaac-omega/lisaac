Header
  + name := USTRING;
  /*UTF8 STRINGs.*/
  - export  := USTRING_BUFFER;

Insert
  - parent_clone:CLONE := CLONE

STRING, FILE_SYSTEM, INTN_BIG, FILE_UTILS
  + storage:NATIVE_ARRAY UINTEGER_8; // UTF8 encoding

  + upper_idx:INTEGER := -1; // index of the last one used in `storage'
  
Private
  + count_memory:INTEGER := -1; // when not up to date
  
Private
  - utf8_starter byte:UINTEGER_8 :BOOLEAN <-
  // The one who decides:
  // 0bbb_bbbb
  // 11bb_bbbb
  (
    (byte & 1100_0000b) != 128
  )
  
  - utf8_follower byte:UINTEGER_8 :BOOLEAN <-
  // Second, third or fourth:
  // 10bb_bbbb
  (
    (byte & 1100_0000b) = 128
  )
  
  - normalize stridx:STRIDX :INTEGER <-
  [
    ? {stridx != STRIDX.not_valid}
    //? {valid_index stridx}; // DCDC recursive....
  ]
  ( + offset,result:INTEGER_64
    + char:CHAR
    ((result := CAST STRIDX TO INTEGER_64.on stridx) = -1).if {
      result := -1
    } else {
      result := stridx.base
      offset := stridx.offset
      (offset > 0).if {
        {offset = 0}.until_do {
          offset := offset - 1
          (result,char) := next result
        }
      }.elseif {offset < 0} then {
        {offset = 0}.until_do {
          offset := offset + 1
          (result,char) := previous result
        }
      }
    }
    result
  )
  
  - next bidx:INTEGER :(INTEGER,CHAR) <-
  // First result gives the next index or (`upper_idx` + 1).
  // Second result is the CHARacter at `bidx`.
  [
    ? {bidx.in_range 0 to upper_idx}
    ? {utf8_starter bidx}
  ]
  ( + r,s:INTEGER
    + char:UINTEGER_32
    r := bidx
    {
      char := (storage.at r.to_uinteger_32 << s) | char
      (r,s) := (r + 1, s + 8)
    }.do_while {(r <= upper_idx) && {(storage.at r & 11_00_0000b) = 10_00_0000b}}
    (r,CHAR.to_self char)
  )
  
  - previous bidx:INTEGER :(INTEGER,CHAR) <-
  // First result gives the previous index or -1.
  // Second result, when -1 is not reached, gives the CHARacter just before `bidx`.
  [
    ? {bidx.in_range 0 to upper_idx}
    ? {utf8_starter bidx}
  ]
  ( + r,s:INTEGER
    + char:UINTEGER_32
    r := bidx - 1
    {(r < 0) || {utf8_starter (storage.at r)}}.until_do {
      char := (storage.at r .to_uinteger_32 << s) | char
      (r,s) := (r - 1,s + 8)
    }
    (r >= 0).if {
      char := (storage.at r .to_uinteger_32 << s) | char
    }
    (r,CHAR.to_self char)
  )
  
Public
  - count:INTEGER <-
  // In number of CHARacters.
  ( + result:INTEGER
    (count_memory < 0).if {
      foreach {c:CHAR
        result := result + 1
      }
      count_memory := result
    } else {
      result := count_memory
    }
    result
  )
  
  - upper:STRIDX <-
  ( + result:INTEGER
    result := upper_idx
    (result >= 0).if {
      {utf8_starter (storage.at result)}.until_do {
        result := result - 1
      }
    }
    STRIDX.to_self result
  )

  - lower:STRIDX <- STRIDX.to_self 0

  - tmp:USTRING_BUFFER := USTRING_BUFFER.create 512
  
  // Access.

  - at i:STRIDX :CHAR <-
  // Unicode 32 bits CHAR at position `i'.
  [
    ? {valid_index i}
  ]
  ( + char:CHAR
    + bidx:INTEGER
    bidx := normalize i
    (bidx,char) := next bidx
    char
  )

  - at_utf8 byte_idx:INTEGER :UINTEGER_8 <-
  // Low level access in utf8 storage (see also `at`).
  [
    ? {byte_idx.in_range 0 to upper_idx}
  ]
  (
    storage.at byte_idx
  )

  // Switch case :

  - when val:USTRING then block:{} :USTRING <-
  // When `Self' equal `val', execute `block'
  (
    (Self === val).if block
    Self
  )

  - when value1:USTRING or value2:USTRING then block:{} :USTRING <-
  // When `Self' equal `value1' or `value2', execute `block'
  (
    ((Self === value1) || {Self === value2}).if block
    Self
  )

  - case val:USTRING then block:{} :USTRING <-
  // * See: `when_then'
  ( + result :USTRING
    ((Self != USTRING) && {Self === val}).if {
      block.value
      result := USTRING
    } else {
      result := Self
    }
    result
  )

  - case_if test:{BOOLEAN} then block:{} :USTRING <-
  // If `test' is true then `block'
  ( + result :USTRING
    ((Self != USTRING) && test).if {
      block.value
      result := USTRING
    } else {
      result := Self
    }
    result
  )

  - case_else block:{} <-
  // otherwise, execute `block'
  (
    (Self != USTRING).if block
  )
  
  // Traversal.
  
  - foreach do:{CHAR; } <-
  ( + bidx:INTEGER
    + char:CHAR
    {bidx <= upper_idx}.while_do {
      (bidx,char) := next bidx
      do.value char
    }
  )
  
  - foreach_utf8 do:{UINTEGER_8; } <-
  ( + bidx:INTEGER
    + char:CHAR
    {bidx > upper_idx}.until_do {
      do.value (storage.at bidx)
      bidx := bidx + 1
    }
  )
  
  - forward start:STRIDX search cond:{CHAR; BOOLEAN} :STRIDX <-
  // Search forward, from `start` index until `cond` or until out of bounds.
  // Returns the corresponding index.
  [
    ? {valid_index start}
  ]
  ( + result:STRIDX
    + bidx,bidx2:INTEGER
    + char:CHAR
    + mem:BOOLEAN
    bidx := normalize start
    (bidx2,char) := next bidx
    {(mem := (cond.value char)) || {bidx2 > upper_idx}}.until_do {
      bidx := bidx2
      (bidx2,char) := next bidx
    }
    mem.if {
      result := STRIDX.to_self bidx
    } else {
      result := STRIDX.not_valid
    }
    result
  )
  
  - backward start:STRIDX search cond:{CHAR; BOOLEAN} :STRIDX <-
  // Search backward, from `start` index until `cond` or until out of bounds.
  // Returns the corresponding index.
  [
    ? {valid_index start}
  ]
  ( + result:STRIDX
    + bidx,bidx2:INTEGER
    + char:CHAR
    bidx := normalize start
    (bidx2,char) := next bidx
    {(bidx < 0) || {cond.value char}}.until_do {
      (bidx,char) := previous bidx
    }
    (bidx < 0).if {
      result := STRIDX.not_valid
    } else {
      result := STRIDX.to_self bidx
    }
    result
  )
  
  
  // Testing.

  - valid_index i:STRIDX :BOOLEAN <-
  // True when `i' is valid (i.e., inside actual bounds).
  ( + result:BOOLEAN
    + bidx:INTEGER
    (i != STRIDX.not_valid).if {
      bidx := normalize i
      result := bidx.in_range 0 to upper_idx
      ? {(!result) || {utf8_starter bidx}}
    }
    result
  )

  - is_empty: BOOLEAN <- upper_idx < 0

  - hash_code: INTEGER <- hash_code_intern
  
  - Self:SELF '<' other:SELF :BOOLEAN <- Self ~< other

  - Self:SELF '~>' other:USTRING :BOOLEAN <- other ~< Self

  - Self:SELF '~<' other:USTRING :BOOLEAN <-
  // Is Current less than `other' ?
  ( + i: INTEGER
    + result: BOOLEAN
    {(i > upper) || {i > other.upper} || {item i != other.item i}}.until_do {
      i := i + 1
    }
    (i > upper).if {
      result := other.upper >= i
    } else {
      (i <= other.upper).if {
        result := item i < other.item i
      }
    }
    result
  )

  - Self:SELF '!<' other:USTRING :BOOLEAN <-
  // Is Current less than `other' ? But, the `upper' to `lower' comparaison
  ( + i1,i2: INTEGER
    + result:BOOLEAN
    i1 := upper
    i2 := other.upper
    {(i1 < lower) || {i2 < other.lower} || {item i1 != other.item i2}}.until_do {
      i1 := i1 - 1
      i2 := i2 - 1
    }
    (i1 < lower).if {
      result := i2 >= other.lower
    } else {
      (i2 >= other.lower).if {
        result := item i1 < other.item i2
      }
    }
    result
  )

  - compare other:USTRING :INTEGER <-
  // Compare alphabetically `Self' to `other'
  ( + i: INTEGER
    + result:INTEGER
    {(i > upper) || {i > other.upper} || {item i != other.item i}}.until_do {
      i := i + 1
    }
    (i > upper).if {
      (i > other.upper).if {
        result := 0
      } else {
        result := -1
      }
    } else {
      (i > other.upper).if {
        result := 1
      } else {
        (item i < other.item i).if {
          result := -1
        } else {
          result := 1
        }
      }
    }
    result
  )

  - same_as other:USTRING :BOOLEAN <-
  // Case insensitive `=='.
  ( + s1,s2:NATIVE_ARRAY CHAR
    + i:INTEGER
    + result:BOOLEAN
    ? {other != NULL}
    i := upper
    (i = other.upper).if {
      (storage.fast_memcmp (other.storage) until i).if {
        result := TRUE
      } else {        
        s1 := storage
        s2 := other.storage
        result := TRUE
        {(i!=0) && {result}}.while_do {
          result:=s1.item i.same_as (s2.item i)
          i:=i-1
        }
      }
    }
    result
  )
  
  - Self:SELF '==' Left 40 other:E :BOOLEAN <-
  // Has Current the same text as `other' ?
  ( + str:USTRING
    str ?= other
    (str != NULL) && {Self === str}
  )

  - Self:SELF '===' Left 40 other:USTRING :BOOLEAN <-
  // Has Current the same text as `other' ?
  ( + result:BOOLEAN
    (Self = other).if {
      result := TRUE
    }.elseif {other != NULL} then {      
      (upper = other.upper).if {
        (upper = -1).if {
          result := TRUE
        } else {
          result:=storage.fast_memcmp (other.storage) until upper
        }
      }
    }
    result
  )

  - index_of c:CHAR start index:STRIDX :STRIDX <-
  // Index of first occurrence of `c' at or after `start_index'.
  // or some non valid_index, if none.
  [
    ? {valid_index index}
  ]
  ( + bidx,bidx2:INTEGER
    + c2:CHAR
    + result:STRIDX
    bidx := normalize index
    {((bidx2,c2) := next bidx; c = c2) || {bidx2 > upper_idx}}.until_do {
      bidx := bidx2
    }
    (c = c2).if {
      result := STRIDX.to_self bidx
    } else {
      result := STRIDX.not_valid
    }
    result
  )

  - new_last_index_of c:CHAR start index:STRIDX :STRIDX <-
  // DCDC index_of x start y reverse
  // Index of first occurrence of `c' at or before `index',
  // -1 if none.
  [
    ? {valid_index index}
  ]
  (
    upper.reverse Self search {c2:CHAR; c = c2}
  )
  - last_index_of c:CHAR start index:STRIDX :STRIDX <-
  // DCDC index_of x start y reverse
  // Index of first occurrence of `c' at or before `start_index',
  // -1 if none.
  [
    ? {valid_index index}
  ]
  ( + bidx,bidx2:INTEGER_64
    + c2:CHAR
    + result:STRIDX
    bidx := normalize index
    {
      (((bidx2,c2) := previous bidx); (c2 = c)) ||
      {bidx2 <= 0}
    }.until_do {
      bidx := bidx2
    }
    (c2 = c).if {
      result := STRIDX.to_self bidx
    } else {
      result := STRIDX.not_valid
    }
    result
  )

  - index_of c:CHAR :STRIDX <-
  // Gives the index of the first occurrence of 'c' or some non valid index if none.
  (
    index_of c start lower
  )

  - first_difference_index other:STRING :INTEGER <-
  // First difference index with `other'.
  // if `other' is equal `Self', return `upper' + 1
  [ -? {other != NULL}; ]
  ( + result:INTEGER

    (Self = other).if {
      result := upper + 1
    } else {
      result := lower
      {
        (result <= upper) &&
        {result <= other.upper} &&
        {item result = other.item result}
      }.while_do {
        result := result + 1
      }
    }
    result
  )
  
  - reverse_first_difference_index other:STRING :(INTEGER,INTEGER) <-
  // First result: index in Self, Second result: index in other.
  ( + i,io:INTEGER
    i := upper
    io := other.upper
    {(i >= 0) && {io >= 0} && {item i = other.item io}}.while_do {
      i := i - 1
      io := io - 1
    }
    i,io
  )

  - has ch:CHARACTER :BOOLEAN <- storage.fast_has ch until upper
  // True if `ch' is in the STRING_BUFFER.

  - has_substring other:STRING :BOOLEAN <-
  // True if `other' is in the STRING_BUFFER.
  ( first_substring_index other != -1 )
  
  - submatch other:STRING separator sep:CHARACTER :INTEGER <-
  // Ex.: "home.ben.java.lang.string".submatch "string.length" separator '.'  
  //                                ^          ^      R=6
  // else R=0
  [ ? {! other.is_empty}; ? {! is_empty}; ] 
  ( + io,is:INTEGER
    + result,cur_is,last_sep_o:INTEGER
    {(is <= upper) && {result != other.count}}.while_do {      
      cur_is := is
      io := 0
      {(cur_is <= upper) && {io <= other.upper} && {item cur_is = other.item io}}.while_do {
        (other.item io = sep).if { last_sep_o := io; }
        cur_is := cur_is + 1
        io := io + 1
      }
      (cur_is > upper).if { 
        ((io > other.upper) || {other.item io = sep}).if { 
          result := io
        } else { 
          result := result.max last_sep_o
        }
      }
      {(is <= upper) && {item is != sep}}.while_do {
        is := is + 1
      }
      is := is + 1
    }
    result
  )
  
  - occurrences c:CHARACTER :INTEGER <-
  // Number of times character `c' appears in the string.
  (
    occurrences c until upper
  )
  
  - occurrences c:CHARACTER until up:INTEGER :INTEGER <-
  (
    storage.fast_occurrences c until up
  )

  - has_suffix s:STRING :BOOLEAN <-
  // True if suffix of `Current' is `s'.
  (
    + result:BOOLEAN
    + i1,i2:INTEGER

    ? { s != NULL }

    (s.upper <= upper).if {
      i1 := upper - s.upper
      i2 := 0
      { (i1 > upper) || { i2 > s.upper} || { item i1 != s.item i2}}.until_do {
        i1 := i1 + 1
        i2 := i2 + 1
      }
      result := i1 > upper
    }

    result
  )

  - has_prefix p:STRING :BOOLEAN <-
  // True if prefix of `Current' is `p'.
  [ ? { p != NULL }; ]
  ( + result:BOOLEAN
    + i:INTEGER
    (p.upper <= upper).if {
      i := p.upper
      {(i = -1) || { item i != p.item i}}.until_do {
        i := i - 1
      }
      result := i = -1
    }
    result
  )

  // Testing and Conversion:
  
  - is_uppercase_identifier:BOOLEAN <-
  // 'A'-'Z' {'A'-'Z' | '0'-'9' | '_'}
  ( + i:INTEGER
    + c:CHARACTER
    {(i <= upper) && {(c := item i).is_upper || {c.is_digit} || {c = '_'}}}.while_do {
      i := i + 1
    }
    i > upper
  )
  
  - is_boolean:BOOLEAN <-
  // does self represent a BOOLEAN?
  // valid BOOLEANS are "TRUE" and "FALSE".
  (
    (Self == "TRUE") || { Self == "FALSE"}
  )

  - to_boolean:BOOLEAN <-
  // Boolean value
  // "true" yields true, "false" yields false (what a surprise).
  (
    ?{ is_boolean }
    Self == "TRUE"
  )

  - is_bit:BOOLEAN <-
  // True when the contents is a sequence of bits (i.e., mixed
  // characters `0' and characters `1').
  ( + i:INTEGER
    + result:BOOLEAN
    i := upper
    result := TRUE
    { (! result) || { i = -1}}.until_do {
      result := item i.is_bit
      i := i - 1
    }
    ? {result = (count = occurrences '0' + occurrences '1')}
    result
  )

  - is_integer:BOOLEAN <-
  // Does self represent an INTEGER?
  // `Result' is true if and only if the following two conditions hold:
  // 1. In the following BNF grammar, the value of self can be
  // produced by "Integer_literal", if leading and trailing
  // separators are ignored:
  // Integer_literal = ['+'|'-'] Digit { Digit }
  // Digit           = '0' .. "9"
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type INTEGER.
  ( + result:BOOLEAN
    + cc: CHARACTER
    + i:INTEGER
    
    (is_empty).if_false {      
      cc := item 0
      ((cc = '-') || {cc = '+'}).if {
        i := 1
      }
      (i <= upper).if {
        {(i <= upper) && {item i.is_digit}}.while_do {
          i := i + 1
        }
        result := i > upper
      }
    }
    result
  )
  
  - is_integer_64:BOOLEAN <-
  // Does self represent an INTEGER_64?
  // `Result' is true if and only if the following two conditions hold:
  // 1. In the following BNF grammar, the value of self can be
  // produced by "Integer_literal", if leading and trailing
  // separators are ignored:
  // Integer_literal = [Sign] Integer
  // Sign            = "+" | "-"
  // Integer         = Digit | Digit Integer
  // Digit           = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type INTEGER_64.
  (
    + i, state: INTEGER
    + value:INTEGER_64
    + negative: BOOLEAN
    + result:BOOLEAN
    + cc: CHARACTER

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.
    // state 4: error.

    i := 0
    { (state = 4) || {i > upper}}.until_do {
      cc := item i
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        }.elseif {cc.is_digit} then {
          value := cc.decimal_value
          state := 2
        } else {
          state := 4
        }
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value := cc.decimal_value
          negative.if {
            value := - value
          }
          state := 2
        } else {
          state := 4
        }
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          negative.if {
            value := value * 10 - cc.decimal_value
          } else {
            value := value * 10 + cc.decimal_value
          }
          // over/underflow check here
          ((negative && {value > 0}) || { ! negative && {value < 0}}).if {
            state := 4
          }
        }.elseif {cc.is_separator} then {
          state := 3
        } else {
          state := 4
        }
      }.elseif { state = 3 } then {
        cc.is_separator.if {
        } else {
          state := 4
        }
      }
      i := i + 1
    }
    ( (state != 0) && { state != 4}).if {
      result := TRUE
    }

    result
  )
    
  - to_integer:INTEGER <-
  // self must look like an INTEGER.
  (
    + i, state:INTEGER
    + cc: CHARACTER
    + negative: BOOLEAN
    + result:INTEGER

    ? { is_integer }
    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.

    i := 0

    { i > upper}.until_do {
      cc := item i

      (state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        } else { // cc.is_digit
          result := cc.decimal_value
          state := 2
        }
      }.elseif { state = 1 } then {
        // cc.is_digit
        result := cc.decimal_value
        negative.if {
          result := - result
        }
        state := 2
      }.elseif { state = 2} then {
        cc.is_digit.if {
          negative.if {
            result := 10 * result - cc.decimal_value
          } else {
            result := 10 * result + cc.decimal_value
          }
        } else { // cc.is_separator
          state := 3
        }
      }.elseif { state = 3 } then {
        // cc.is_separator
        i := upper; // terminate the loop
      }

      i := i + 1
    }

    result
  )

  - to_integer_64:INTEGER_64 <-
  // self must look like an INTEGER.
  ( + i, state:INTEGER
    + cc: CHARACTER
    + negative: BOOLEAN
    + result:INTEGER_64

    ? { is_integer_64 }
    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.

    i := 0
    {i > upper}.until_do {
      cc := item i

      (state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        } else { // cc.is_digit
          result := cc.decimal_value
          state := 2
        }
      }.elseif { state = 1 } then {
        // cc.is_digit
        result := cc.decimal_value
        negative.if {
          result := - result
        }
        state := 2
      }.elseif { state = 2} then {
        cc.is_digit.if {
          negative.if {
            result := result * 10 - cc.decimal_value
          } else {
            result := result * 10 + cc.decimal_value
          }
        } else { // cc.is_separator
          state := 3
        }
      }.elseif { state = 3 } then {
        // cc.is_separator
        i := upper; // terminate the loop
      }
      i := i + 1
    }

    result
  )
  
  - is_hexadecimal:BOOLEAN <-
  ( + j:INTEGER
    + result:BOOLEAN
    (is_empty).if_false {
      j := lower
      {(j > upper) || {! item j.is_hexadecimal_digit}}.until_do {
        j:=j+1
      }
      result := j > upper
    }
    result
  )

  - to_hexadecimal:UINTEGER_64 <-
  ( + result:UINTEGER_64
    ? {is_hexadecimal}
    lower.to upper do { j:INTEGER
      result := (result << 4) | item j.hexadecimal_value
    }
    result
  )

  - is_octal :BOOLEAN <-
  ( + result:BOOLEAN
    + j:INTEGER
    (is_empty).if_false {
      j := lower
      {(j > upper) || {! item j.is_octal_digit}}.until_do {
        j:=j+1
      }
      result:= j > upper
    }
    result
  )

  - to_octal:UINTEGER_64 <-
  ( + result:UINTEGER_64
    ? {is_octal}

    lower.to upper do { j:INTEGER
      result := (result << 3) | item j.octal_value
    }
    result
  )

  - is_binary:BOOLEAN <-
  ( + result:BOOLEAN
    + j:INTEGER

    (is_empty).if_false {
      j := lower
      { (j > upper) || {! item j.is_binary_digit} }.until_do {
        j := j + 1
      }

      result := j > upper
    }

    result
  )

  - to_binary :UINTEGER_64 <-
  ( + result:UINTEGER_64
    ? {is_bit}

    lower.to upper do { j:INTEGER
      result := result << 1
      (item j = '1').if {
        result := result | 1
      }
    }
    result
  )

  - is_real_16_16:BOOLEAN <-
  // Does self represent an REAL_16_16 ?
  // `Result' is true if and only if the following two conditions hold:
  // 1. In the following BNF grammar, the value of self can be
  // produced by "real_literal", if leading and trailing
  // separators are ignored:
  // Real_literal = [Sign] Integer [Point Integer]
  // Sign            = "+" | "-"
  // Point           = "."
  // Integer         = Digit | Digit Integer
  // Digit           = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type REAL_16_16.
  (
    + i, state, value_int: INTEGER
    + value:REAL_16_16
    + negative: BOOLEAN
    + result:BOOLEAN
    + cc: CHARACTER
    + d:INTEGER

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number before the point
    // state 3: in the number after the point
    // state 4: after the number.
    // state 5: error.

    i := 0
    d := 1

    { (state = 5) || {i > upper}}.until_do {
      cc := item i
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        }.elseif {cc.is_digit} then {
          value_int := cc.decimal_value
          state := 2
        } else {
          state := 5
        }
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value_int := cc.decimal_value
          state := 2
        } else {
          state := 5
        }
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          value_int := 10 * value_int + cc.decimal_value
          (value_int < 0).if {
            state := 5
          }
        }.elseif { cc = '.' } then {
          state := 3
          value := value_int.to_real_16_16
        }.elseif {cc.is_separator} then {
          state := 4
        } else {
          state := 5
        }
      }.elseif { state = 3 } then {
        cc.is_digit.if {
          d := d * 10
          value := value + (cc.decimal_value.to_real_16_16) /# d
        }.elseif {cc.is_separator} then {
          state := 4
        } else {
          state := 5
        }
      }.elseif { state = 4 } then {
        cc.is_separator.if {
        } else {
          state := 5
        }
      }

      i := i + 1
    }
    negative.if {
      value := - value
    }
    ( (state != 0) && { state != 5}).if {
      result := TRUE
    }

    result
  )

  - to_real_16_16:REAL_16_16 <-
  (
    + i, state, value_int: INTEGER
    + value:REAL_16_16
    + negative: BOOLEAN
    + cc: CHARACTER
    + d:INTEGER

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number before the point
    // state 3: in the number after the point
    // state 4: after the number.

    i := 0
    d := 1

    {i > upper}.until_do {
      cc := item i
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1
        }.elseif {cc = '-'} then {
          negative := TRUE
          state := 1
        }.elseif {cc.is_digit} then {
          value_int := cc.decimal_value
          state := 2
        }
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value_int := cc.decimal_value
          state := 2
        }
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          value_int := value_int * 10 + cc.decimal_value
        }.elseif { cc = '.' } then {
          state := 3
          value := value_int.to_real_16_16
        } else {  // cc is separator
          value := value_int.to_real_16_16
          state := 4
        }
      }.elseif { state = 3 } then {
        cc.is_digit.if {
          d := d * 10
          value := value + (cc.decimal_value.to_real_16_16) /# d
        } else { // cc is separator
          state := 4
        }
      }.elseif { state = 4 } then {
        // cc is separator
        i := count;  // terminate the loop
      }

      i := i + 1
    }

    (state = 2).if {
      value := value_int.to_real_16_16
    }

    negative.if {
      value := - value
    }

    value
  )
  
  // Loop.
  
  - do_all do:{CHARACTER;} <-
  (
    0.to upper do { i:INTEGER
      do.value (item i)
    }
  )
  
  // Modification:

  - Self:SELF '+' other:STRING :STRING_BUFFER <-
  // Create a new STRING_BUFFER which is the concatenation of
  // `self' and `other'.
  [
    -? {other != NULL}
  ]
  ( + result:STRING_BUFFER
    result:=STRING_BUFFER.create (count + other.count)
    result.append Self
    result.append other
    result
  )
  [
    +? {Result.count = Old count + other.count}
  ]
  
  - as_lower:STRING_BUFFER <-
  // New object with all letters in lower case.
  (
    + result:STRING_BUFFER
    result := STRING_BUFFER.create capacity
    result.copy Self
    result.to_lower
    result
  )

  - as_upper:STRING_BUFFER <-
  // New object with all letters in upper case.
  (
    + result:STRING_BUFFER
    result := STRING_BUFFER.create capacity
    result.copy Self
    result.to_upper
    result
  )

  // Other features:

  - first:CHARACTER <-
  // Access to the very `first' character.
  [ ? {! is_empty}; ]
  ( storage.item 0 )
  [ /*? { result == item lower};*/ ]
  
  - second:CHARACTER <-
  // Access to the very `second' character.
  [ ? {upper > 0}; ]
  ( storage.item 1 )
  [ /*? { result == item (lower+1)};*/ ]

  - last:CHARACTER <-
  // Access to the very `last' character.
  (
    + result:CHARACTER
    ? {! is_empty}

    result := storage.item upper

    ? { result = item upper}
    result
  )
  
  - substring start_index:INTEGER to end_index:INTEGER in str:STRING_BUFFER <-
  // New string consisting of items [`start_index'.. `end_index'].
  [
    -? { start_index >= 0 }
    -? { end_index <= upper }
    -? { start_index <= end_index + 1 }
  ]
  ( + c:INTEGER
    c := end_index - start_index + 1
    str.set_capacity c
    str.set_upper (c-1)
    str.storage.slice_copy storage to 0 from start_index to end_index
  )
  
  - substring start_index:INTEGER to end_index:INTEGER :STRING_BUFFER <-
  // New string consisting of items [`start_index'.. `end_index'].
  [
    -? { start_index >= 0 }
    -? { end_index <= upper }
    -? { start_index <= end_index + 1 }
  ]
  ( + c:INTEGER
    + result:STRING_BUFFER

    c := end_index - start_index + 1
    result := STRING_BUFFER.create c
    result.set_upper (c-1)
    result.storage.slice_copy storage to 0 from start_index to end_index

    result
  )
  [
    +? { Result.count = end_index - start_index + 1 }
  ]

  - substring_begin start:INTEGER to_begin end:INTEGER :STRING_BUFFER <-
  (
    substring start to end
  )

  - substring_begin start:INTEGER to_end end:INTEGER :STRING_BUFFER <-
  (
    substring start to (upper-end-1)
  )

  - substring_end start:INTEGER to_end end:INTEGER :STRING_BUFFER <-
  (
    substring (upper-start-1) to (upper-end-1)
  )
  
  - max_match from:INTEGER on other:STRING from start_other:INTEGER :(INTEGER,INTEGER) <-
  ( + result,i:INTEGER
    result := from
    i := start_other
    {(result <= upper) && {i <= other.upper} && 
    {item result = other.item i}}.while_do {
      result := result + 1
      i := i + 1
    }
    result, i
  )
  
  - substring_index (other:STRING,start_index:INTEGER) :INTEGER <-
  // Position of the first occurrence of `other' at or after 0
  // or -1 if none. // BSBS->DCDC renvoyer plutot upper+1 ce serait mieux...
  ( + i,s,result:INTEGER

    ? {! other.is_empty }
    ? { (start_index >=0) && { start_index <= upper + 1 }}
    result := -1
    s := start_index
    {(result != -1) || {(s + other.upper) > upper}}.until_do {
      i := 0
      {(i > other.upper) || {item (s + i) != other.item i}}.until_do {
        i := i + 1
      }
      (i > other.upper).if {
        result := s
      } else {
        s := s + 1
      }
    }
    result
  )

  - first_substring_index other:STRING :INTEGER <-
  // Position of the first occurrence of `other' at or after 0
  // or -1 if none.
  (
    ? {! other.is_empty }

    substring_index (other,0)
  )

  // Splitting a STRING_BUFFER:
  
  /*
  - partition sep:STRING from start_index:INTEGER :(STRING_BUFFER, STRING_BUFFER, STRING_BUFFER) <-
  [
    -? {sep != NULL}
    -? {valid_index start_index}
  ]
  ( + i, j:INTEGER
    + head, sep, tail :STRING_BUFFER
    i := substring_index (sep, start_index)
    (i = 0).if {
      // Not found
      head := to_string_buffer
    } else {
      // Found
      j := i + sep.count
      (i > lower).if {
        head := substring lower to (i-1)
      }
      sep  := substring i to j
      (j < upper).if {
        tail := substring (j+1) to upper
      }
    }
    head, sep, tail
  )

  - partition sep:STRING :(STRING_BUFFER, STRING_BUFFER, STRING_BUFFER) <-
  (
    partition sep from lower
  )
*/
  - split_str sep:STRING :ARRAY(STRING_BUFFER) <-
  [
    -? {sep != NULL}
  ]
  ( + result:ARRAY(STRING_BUFFER)
    ( count > 0 ).if {
      split_buffer.clear
      split_str sep in split_buffer
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper)
        result.copy split_buffer
      }
    }

    result
  )
  [
    +? { (Result != NULL) ->> { ! Result.is_empty }}
  ]

  - split_str sep:STRING in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split_str' but result is appended in `words'.
  [
    -? {words != NULL}
    -? {sep != NULL}
  ]
  ( + i, j:INTEGER
    // i    first character of the next word
    // j-1  last character of the next word
    // j    first character of the next separator

    i := 0
    { j := substring_index(sep, i); j != -1 }.while_do {
      words.add_last (substring i to (j-1))
      i := j + sep.count
    }
    words.add_last (substring i to upper)
  )

  - split:ARRAY(STRING_BUFFER) <-
  // Split the string into an array of words. Uses `is_separator' of
  // CHARACTER to find words. Gives Void or a non empty array.
  (
    + result:ARRAY(STRING_BUFFER)
    (upper >= 0 ).if {
      split_buffer.clear
      split_in split_buffer
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper)
        result.copy split_buffer
      }
    }
    ? { (result != NULL) ->> { ! result.is_empty }}

    result
  )

  - split_in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split' but result is appended in `words'.
  (
    + state,old_count: INTEGER
    // state = 0: waiting next word.
    // state = 1: inside a new word.
    + c: CHARACTER

    ? { words != NULL}
    old_count := words.count
    (upper >= 0).if {
      lower.to upper do { i:INTEGER
        c := item i
        (state = 0).if {
          (! c.is_separator).if {
            string_buffer.clear
            string_buffer.append_character c
            state := 1
          }
        } else {
          (! c.is_separator).if {
            string_buffer.append_character c
          } else {
            words.add_last (string_buffer.twin)
            state := 0
          }
        }
      }
      ( state = 1).if {
        words.add_last (string_buffer.twin)
      }
    }

    ? { (words.count) >= old_count }
  )
  
  - is_upper:BOOLEAN <-
  // True, if all characters `is_upper' or '_' or digit.
  ( + i:INTEGER
    + c:CHARACTER
    i := lower
    {(i <= upper) && {
      (c := item i; c.is_upper) || {c = '_'} || {c.is_digit}}
    }.while_do { 
      i := i + 1
    }
    i > upper
  )
  
  - split_at sep:CHARACTER :ARRAY(STRING_BUFFER) <-
  // Split the string at characters `c' into an array of words.
  (
    + result:ARRAY(STRING_BUFFER)
    ( count > 0 ).if {
      split_buffer.clear
      split_at sep in split_buffer
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper)
        result.copy split_buffer
      }
    }

    result
  )
  [
    +? { (Result != NULL) ->> { ! Result.is_empty }}
  ]

  - split_at sep:CHARACTER in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split' but result is appended in `words'.
  (
    + state,old_count: INTEGER
    // state = 0: waiting next word.
    // state = 1: inside a new word.
    + c: CHARACTER

    ? { words != NULL}
    old_count := words.count
    (count > 0).if {
      0.to upper do { i:INTEGER
        c := item i
        (state = 0).if {
          (c != sep).if {
            string_buffer.clear
            string_buffer.append_character c
            state := 1
          }
        } else {
          (c != sep).if {
            string_buffer.append_character c
          } else {
            words.add_last (string_buffer.twin)
            state := 0
          }
        }
      }
      ( state = 1).if {
        words.add_last (string_buffer.twin)
      }
    }

    ? { (words.count) >= old_count }
  )

  - to_string_buffer:STRING_BUFFER <-
  // New STRING_BUFFER having the same character sequence as self.
  // Useful in proper descendants of STRING_BUFFER.
  (
    STRING_BUFFER.create_from_string Self
  )
  
  - to_string_alias:STRING_ALIAS <-
  (
    abstract
    NULL
  )

  - to_string:STRING_ALIAS <- to_string_alias
  
STRING
  - string_buffer:STRING_BUFFER := STRING_BUFFER.create 256; // Private, temporary once buffer.

  - split_buffer:ARRAY(STRING_BUFFER) := ARRAY(STRING_BUFFER).create_with_capacity 4 lower 1

Public
  - print <-
  (    
    0.to upper do { i:INTEGER
      STDOUT.put_character (storage.item i)
    }
  )
  
  - print_error <-
  (    
    0.to upper do { i:INTEGER
      STDERR.put_character (storage.item i)
    }
  )
  
  - to_external:NATIVE_ARRAY CHARACTER <-
  // Gives C access to the internal `storage' (may be dangerous).
  // To be compatible with C, a null character is added at the end
  // of the internal `storage'. This extra null character is not
  // part of the Lisaac STRING_BUFFER.
  (
    abstract
    NULL
  )
  
STRING
  - hash_code_intern: INTEGER <-
  ( + result,up:INTEGER
    up := upper.min 32
    0.to up do { i:INTEGER
      result := (result << 2) + item i.code
    }
    result & 07FFF_FFFFh
  )

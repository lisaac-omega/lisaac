Header
  + name := TOK_DRW;
  
Insert
  + parent_txt_buf:TXT_BUF := TXT_BUF
  
Inherit
  - parent_clone:CLONE := CLONE; // Just for DIV.data:CLONE

Public
  
  - is_major:BOOLEAN := TRUE
  - di_major:INTEGER <- ( ? {is_major}; di)
  
  - txt_buf:TXT_BUF <- parent_txt_buf
  //- set_p_txt_buf t:TXT_BUF <- ( parent_txt_buf := t; )
  
  - pt_b:POS
  - begin p:POS <-
  (
    TOK_ITM.set_parent_tok_drw Self
    pt_b := p
  )
  
  - new:SELF <- (crash; SELF)
  - free
        
  - begin_draw
  - sub_draw
  - end_draw
  - post_draw
      
  - draw_std e:INTEGER <-
  ( + old_pt:POS
    {pos_i < e}.while_do {
      old_pt := pos_i
      sty_run
      sub_draw
      (old_pt = pos_i).if {        
        at_tmp pos_i
        draw_tmp_c
        pos_i := pos_i + tmp_c.count
      }
    }
    sty_run
    old_pt := pos_i; // DEBUG:
    //pt_ri := pt_ci - pt_b
    sub_draw
    //sty_run
    /*(pos_i != old_pt).if {
      "TOK:".print
      type_name.print; ' '.print
      pos_i.pt.print; '/'.print; old_pt.pt.println
    };*/
    //? {pos_i = old_pt}
  )
  
  //- is_phys:BOOLEAN := TRUE
  
  + di:INTEGER
  - end d:POS :SELF <- ( di := d.pt - pt_b.pt; Self)
  
  + dh:REAL_32; // Delta Height
  //- set_dh h:REAL_32 <- ( dh := h; )
    
  + nl:INTEGER
  - inc_nl <- ( nl := nl + 1; )
  - dec_nl <- ( nl := nl - 1; )
  - set_nl l:INTEGER <- ( nl := l; )
  
  - cmd_new_line:BOOLEAN <-
  ( + r:BOOLEAN
    r := txt_buf.cmd_add "\n"
    (r && {auto_indent}).if {
      pos := pos + indent_line (pos-1)
      pos := pos + indent_line pos
    }
    r
  )
  
  - cmd_new_line2:BOOLEAN <-
  ( + r:BOOLEAN
    r := txt_buf.cmd_add "\r\n"
    (r && {auto_indent}).if {
      pos := pos + indent_line (pos-2)
      pos := pos + indent_line pos
    }
    r
  )
  
  - cmd_suppr:BOOLEAN <- ( txt_buf.rm pos; TRUE)
  
  - printi i:INTEGER <-
  (    
    "=== ".print; i.print; " ===".println
    "Size   : ".print; di.println
    "Size y : ".print; dh.println
  )
  
  - check_end d:INTEGER :BOOLEAN <-
  ( + result:BOOLEAN
    (pt_b+di != d).if {
      "Error TOK_DRW:\n pos real:".print; d.println
      " pt_b:".print; pt_b.print; " + di:".print; di.print; " = ".print; (pt_b+di).println
      result := TRUE
    }
    ? {pt_b+di = d}
    result
  )
  
  - detect:BOOLEAN <-
  [ parent_txt_buf := TXT_BUF.current; ]
  ( abstract; TRUE)
  
  - parse          <- ( abstract; )
  - next_parse
  
  - product <-
  (
    parent_txt_buf := TXT_BUF.current
    nl := 0
    sty.clear
    begin pos_i
    parse
    end pos_i
    
    (! ((pos_i = upper) || {(pos_i-1 < upper) && {at (pos_i-1) = '\n'}})).if {
      "TOK_DRW 103 ".print; type_name.print; ' '.print; pos_i.print
      '/'.print; upper.print
      '\n'.print; at (pos_i-1).to_uinteger_8.print
      " in ".print; name.println
      exit 0
    }
    ? {(pos_i = upper) || {(pos_i-1 < upper) && {at (pos_i-1) = '\n'}}}
    
    ((pos_i = upper) && {(upper = 0) || {at (upper-1) != '\n'}}).if {      
      nl := nl + 1
    }
  )
  
  - is_empty:BOOLEAN <- di = 1
  
  - my_pos:POS <-
  ( + i:INTEGER
    + p:POS
    + t:TOK_DRW
    {(t := toks.at i) != Self}.while_do {      
      p := p + t.di
      i := i + 1
    }
    p
  )
  
  - my_tok_cur:INTEGER <-
  ( + i:INTEGER
    {toks.at i != Self}.while_do { i := i + 1; }
    i
  )
  
  - draw_extern <-
  (
    pos_i := my_pos
    tok_cur := my_tok_cur
    TOK_ITM.set_parent_tok_drw Self
    draw
    TOK_ITM.set_parent_tok_drw (Old TOK_ITM.parent_t_drw)
    tok_cur := Old tok_cur
    pos_i := Old pos_i
  )
  
  - draw <-
  ( + e,i,v:INTEGER
    + dx:REAL_32
    begin pos_i
    styi := 0
    //pt_ri := 0
    begin_draw
    e := pt_b.pt + di
    (pos.in_range (pos_i.pt) to (e-1)).if {
      i := 2
      {(i <= sty.upper) && {sty.at i + pt_b.pt < pos.pt}}.while_do { i := i + 2; }
      (i < sty.upper).if {
        v := sty.at (i+1)
        ((v < 0) && {sty.at (i-1) = v}).if {          
          itm_cur := v; //CAST INTEGER TO TOK_ITM.on (v & 07FFF_FFFF_FFFF_FFFFh)
        }
      }
    } else { itm_cur := -1; }
    //fill_color (COLOR.black)
    draw_std e
    ((pos_i = upper) && {tok_cur = toks.upper}).if { end_text; }
    end_draw
    //
    (DIV.debug_div).if {
      dx := x_space*2
      save
      begin_path
      line (dx,tex.y) to (width-dx,tex.y)
      stroke_width 1.0
      stroke_color (COLOR.white)
      stroke
      fill_color (COLOR.white)
      STRING.tmp { tmp:STRING_BUFFER
        tmp.copy "Tok#"
        tok_cur.append_in tmp
        tmp.append " L"
        nl.append_in tmp
        font_size 15
        text (width-100,tex.y-3) msg tmp
      }
      restore
    }
    //
    post_draw
    dh := tex.y - Old tex.y
  )
  
  - search s:STRING base b:INTEGER at idx:INTEGER :INTEGER <-
  ( ? {idx.in_range 0 to (di-1)}; // No valid for TOK_ITM
    search s range (b+idx) to (b+di-1)
  )
  
  - search_back s:STRING base b:INTEGER at idx:INTEGER :INTEGER <-
  ( ? {idx.in_range 0 to di}; // No valid for TOK_ITM
    search_back s range (b+idx) downto b
  )
  
  // Style / Color
  
  + sty:Expanded ARRAY INTEGER_32
  - styi:INTEGER
  - underline:BOOLEAN
  - last_color:COLOR; // Used LIZ
    
  - sty_run <-
  ( + f,n:INTEGER_32
    + sz:REAL_32
    {(styi <= sty.upper) && {pos_i >= pt_b.pt + sty.at styi}}.while_do {
      f := sty.at (styi+1)
      (f = itm_cur).if {
        underline := !underline
      } else {
        n := f & 0FFh
        (f >> 8)
        .when 0 then { // Color
          /*
          (n = 12).if {
            OUT # "Color " # n # " x=" # tex.x # " pt_b=" # pt_b.pt # "\n";
            OUT # "c=" # at pos_i # '\n';
            //(at pos_i = ':').if { exit 1; };
            from (styi) to (sty.upper.min (styi+8)) step 2 do { i:INTEGER;
              sty.at i.print; ' '.print;
            };
            '\n'.print;
          };*/
          last_color := LOOK.cols.at n
          fill_color last_color
          //stroke_color (COLOR.white)
        }
        .when 1 then { // Font
          //OUT # "FONT:" # n # " pos:" # (pt_b.pt + sty.at styi) # '\n'
          FONT.app n in txt_buf
        }
        .when 2 then { // Size
          n
          .when 0 then { sz := FONT.size_app; }
          .when 1 then { sz := FONT.size_app * 0.8; }
          .when 2 then { sz := FONT.size_app * 1.1; }
          font_size sz
        }
        .when 3 then { // Escape character
          (last_div = NULL).if {
            (tex.x = tex.xmin).if { begin_line; }
            last_div := DIV.new.text
          }
          tex.set_x (LOOK.drw n)
          tex.ascdes (asc_c,des_c)
          detect_cur
          pos_i := pos_i + 1
        }
        .when 4 then { // Img
          (! pos.pt.in_range (pos_i.pt) to (pos_i.pt+n)).if {
            STRING.tmp { tmp:STRING_BUFFER
              tmp.copy name
              tmp.remove_suffix shortname
              (pos_i.pt).to (pos_i.pt + n - 1) do { i:INTEGER
                tmp | at i
              }
              (put_image tmp).if {
                pos_i := pos_i + n
              }
            }
          }
        }
      }
      styi := styi + 2
    }
  )
  
  - col n:INTEGER sub s:INTEGER <-
  //[ ? {sty.is_empty || {pos_i.pt - pt_b.pt - s >= sty.second_last}}; ]
  (
    (sty.is_empty || {pos_i.pt - pt_b.pt - s >= sty.second_last}).if_false {
      print_sty 0
    }
    sty.add_last (pos_i.pt - pt_b.pt - s)
    sty.add_last n
  )
  
  - fnt n:INTEGER sub s:INTEGER <-
  [ ? {sty.is_empty || {pos_i.pt - pt_b.pt - s >= sty.second_last}}; ]
  ( sty.add_last (pos_i.pt - pt_b.pt - s)
    sty.add_last (n | 100h)
  )
  
  - fsz n:INTEGER sub s:INTEGER <-
  [ ? {sty.is_empty || {pos_i.pt - pt_b.pt - s >= sty.second_last}}; ]
  ( sty.add_last (pos_i.pt - pt_b.pt - s)
    sty.add_last (n | 200h)
  )
  
  - drw n:INTEGER sub s:INTEGER <-
  [ ? {sty.is_empty || {pos_i.pt - pt_b.pt - s >= sty.second_last}}; ]
  ( sty.add_last (pos_i.pt - pt_b.pt - s)
    sty.add_last (n | 300h)
  )
  
  - img b:INTEGER to e:INTEGER <-
  [ ? {sty.is_empty || {b - pt_b.pt >= sty.second_last}}; ]
  ( sty.add_last (b - pt_b.pt)
    sty.add_last ((e-b) | 400h)
  )
  
  - itm_cur:INTEGER; //OK_ITM
  - itm n:TOK_ITM sub s:INTEGER <-
  [ ? {sty.is_empty || {pos_i.pt - pt_b.pt - s >= sty.second_last}}; ]
  ( sty.add_last (pos_i.pt - pt_b.pt - s)
    sty.add_last (n.to_pointer.to_integer | 8000_0000h)
  )
    
  - print_sty b:INTEGER <-
  ( + f,n:INTEGER_32
    
    "-------------".println
    from 0 to (sty.upper) step 2 do { i:INTEGER
      i.print; ": ".print
      (b + sty.at i).print; ' '.print
      f := sty.at (i+1)
      n := f & 0Fh
      (f >> 8)
      .when 0 then { // Color
        "Color: ".print; n.print; ' '.print
        n
        .when (LOOK.dead) then { "dead".print; }
        .when (LOOK.symbol) then { "symbol".print; }
        .when (LOOK.rmk) then { "rmk".print; }
        .when (LOOK.sub_rmk) then { "sub_rmk".print; }
        .when (LOOK.type) then { "type".print; }
        .when (LOOK.slot) then { "slot".print; }
        .when (LOOK.local) then { "local".print; }
        .when (LOOK.operator) then { "operator".print; }
        .when (LOOK.string) then { "string".print; }
        .when (LOOK.external) then { "external".print; }
        .when (LOOK.number) then { "number".print; }
        .when (LOOK.keyword) then { "keyword".print; }
      }
      .when 1 then { // Font
        "Font: ".print; n.print; ' '.print
        n
        .when (FONT.roman)  then { "Roman".print; }
        .when (FONT.bold)   then { "Bold".print; }
        .when (FONT.italic) then { "Italic".print; }
        .when (FONT.italic | FONT.bold) then { "Bold/Italic".print; }
      }
      .when 2 then { // Size
        "Font size: ".print; n.print; ' '.print
        n
        .when 0 then { "Normal".print; }
        .when 1 then { "80%".print; }
        .when 2 then { "120%".print; }
      }
      .when 3 then { // Special character
        n
        .when 0 then { "Clone".print; }
      }
      ((f >> 8) > 3).if { (f>>8).print; }
      '\n'.print
    }
  )
    
  

Header
  + name := LINKED_LIST V;
  /* Two way linked list with internal automatic memorization 
     of the last access .
  */

Inherit
  + parent_linked_collection:Expanded LINKED_COLLECTION V

LINKED_LIST

  + first_link:LINKED_LIST_NODE V
  // NULL when empty or gives access to the first element.

  + last_link:LINKED_LIST_NODE V
  // NULL when empty or gives access to the last element.

  + mem_idx:INTEGER

  + mem_lnk:LINKED_LIST_NODE V
  // To speed up accessing, `mem_idx' and `mem_lnk' is the
  // memory of the last access done. For example, after
  // item(1), `mem_idx' is 1 and `mem_lnk' is `first_link'.
  // When list is empty, `first_link' is NULL as well as
  // `mem_lnk' and `mem_idx' is 0

Public
  - is_empty:BOOLEAN <- first_link = NULL

  - add_first element:V <-
  (
    (first_link = NULL).if {
      first_link := LINKED_LIST_NODE V.create element previous NULL next NULL
      last_link := first_link
      upper := 0
      mem_idx := 0
      mem_lnk := first_link
    } else {
      first_link := LINKED_LIST_NODE V.create element previous NULL next first_link
      first_link.next.set_previous first_link
      upper := upper + 1
      mem_idx := mem_idx + 1
    }
  )

  - add_last element:V <-
  (
    (first_link = NULL).if {
      first_link := LINKED_LIST_NODE V .create element previous NULL next NULL
      last_link := first_link
      upper := 0
      mem_idx := 0
      mem_lnk := first_link
    } else {
      last_link := LINKED_LIST_NODE V .create element previous last_link next NULL
      last_link.previous.set_next last_link
      upper := upper + 1
    }
  )

  - at i:INTEGER add v:V <-
  ( + link:LINKED_LIST_NODE V
    (i = 0).if {
      add_first v
    }.elseif {i = upper + 1} then {
      add_last v
    } else {
      go_item (i - 1)
      link := LINKED_LIST_NODE V.create v previous mem_lnk next (mem_lnk.next)
      link.next.set_previous link
      mem_lnk.set_next link
      upper := upper + 1
    }
  )

  - remove_first <-
  (
    (upper = 0).if {
      first_link := NULL
      last_link  := NULL
      mem_lnk    := NULL
      mem_idx := -1
      upper   := -1
    } else {
      first_link := first_link.next
      first_link.set_previous NULL
      upper := upper - 1
      (mem_idx > 1).if {
        mem_idx := mem_idx - 1
      } else {
        mem_lnk := first_link
        mem_idx := 0
      }
    }
  )

  - remove index:INTEGER <-
  ( + link:LINKED_LIST_NODE V
    (index = 0).if {
      remove_first
    }.elseif {index = upper} then {
      remove_last
    } else {
      go_item (index - 1)
      link := mem_lnk.next
      mem_lnk.set_next (link.next)
      link.next.set_previous mem_lnk
      upper := upper - 1
    }
  )

  - first:V <- first_link.item

  - last:V <- last_link.item

  - at i:INTEGER :V <-
  (
    go_item i
    mem_lnk.item
  )

  - at i:INTEGER put v:V <-
  (
    go_item i
    mem_lnk.set_item v
  )

  - set_all_with v:V <-
  (
    (first_link != NULL).if {
      first_link.set_all_with v
    }
  )

  - copy other:SELF <-
  (
    from_collection other
  )

  - Self:SELF '==' Right 60 other:SELF :BOOLEAN <-
  ( + result:BOOLEAN
    + lnk1, lnk2:LINKED_LIST_NODE V
    (Self = other).if {
      result := TRUE
    }.elseif {upper = other.upper} then {
      result := TRUE
      lnk1 := first_link
      lnk2 := other.first_link
      {(lnk1 = NULL) || {! result}}.until_do {
        result := lnk1.item = lnk2.item
        lnk1 := lnk1.next
        lnk2 := lnk2.next
      }
    }
    result
  )

  - is_equal_map other:SELF :BOOLEAN <-
  ( + result:BOOLEAN
    + lnk1, lnk2:LINKED_LIST_NODE V
    (Self = other).if {
      result := TRUE
    }.elseif {upper = other.upper} then {
      result := TRUE
      lnk1 := first_link
      lnk2 := other.first_link
      {(lnk1 = NULL) || {! result}}.until_do {
        result := safe_equal (lnk1.item, lnk2.item)
        lnk1 := lnk1.next
        lnk2 := lnk2.next
      }
    }
    result
  )
  
  /*
  - index_of x:V start start_index:INTEGER :INTEGER <-
  ( + result:INTEGER
    + safe_equal:SAFE_EQUAL V

    result := start_index
    {(result > upper) || {safe_equal.test x with (item result)}}.until_do {
      result := result + 1
    }
    result
  )

  - reverse_index_of element:V start start_index:INTEGER :INTEGER <-
  ( + safe_equal:SAFE_EQUAL V
    + temporary_idx:INTEGER
    + temporary_lnk:LINKED_LIST_NODE V
    + result:INTEGER
    go_item start_index
    temporary_idx := mem_idx
    temporary_lnk := mem_lnk
    {(temporary_idx < lower) || {safe_equal.test element with (temporary_lnk.item)}}.until_do {
      temporary_idx := temporary_idx - 1
      temporary_lnk := temporary_lnk.previous
    }
    result := temporary_idx
    (temporary_idx >= lower).if {
      mem_idx := temporary_idx
      mem_lnk := temporary_lnk
    }
    result
  )
  */
  
  - fast_index_of element:V start start_index:INTEGER :INTEGER <-
  ( + result:INTEGER
    + u:INTEGER
    result := lower
    u := upper
    {(result > u) || {element = at result}}.until_do {
      result := result + 1
    }
    result
  )

  - fast_reverse_index_of element:V start start_index:INTEGER :INTEGER <-
  ( + temporary_idx:INTEGER
    + temporary_lnk:LINKED_LIST_NODE V
    + result:INTEGER
    go_item start_index
    temporary_idx := mem_idx
    temporary_lnk := mem_lnk
    {(temporary_idx < lower) || {element = temporary_lnk.item}}.until_do {
      temporary_idx := temporary_idx - 1
      temporary_lnk := temporary_lnk.previous
    }
    result := temporary_idx
    (temporary_idx >= lower).if {
      mem_idx := temporary_idx
      mem_lnk := temporary_lnk
    }
  )

  - clear <-
  (
    (first_link != NULL).if {
      first_link := NULL
      mem_idx := -1
      mem_lnk := NULL
      upper := -1
      last_link := NULL
    }
  )
  [ 
    +? {upper = 0}
  ]

  - from_collection model:COLLECTION V <-
  ( + lnk:LINKED_LIST_NODE V
    (first_link = NULL).if {
      (model.lower).to (model.upper) do { i:INTEGER
        add_last (model.item i)
      }
    } else {
      lnk := first_link
      (model.lower).to (model.upper) do { i:INTEGER
        (lnk = NULL).if {
          add_last (model.item i)
        } else {
          lnk.set_item (model.item i)
          lnk := lnk.next
        }
      }
      (lnk = first_link).if {
        ? {model.count = 0}
        clear
      }.elseif {lnk != NULL} then {
        + i:INTEGER
        i := model.count
        go_item i
        ? {lnk = mem_lnk.next}
        mem_lnk.set_next NULL
        upper := i
        last_link := mem_lnk
      }
    }
  )

  - slice low:INTEGER to up:INTEGER :SELF <-
  ( + lnk:LINKED_LIST_NODE V
    + result:SELF

    result := SELF.create
    (mem_idx != low).if {
      go_item low
    }
    lnk := mem_lnk
    (up - low + 1).downto 1 do { i:INTEGER
      result.add_last (lnk.item)
      lnk := lnk.next
    }
    result
  )
  
  - occurrences element:V :INTEGER <-
  ( + lnk:LINKED_LIST_NODE V
    + safe_equal:SAFE_EQUAL V
    + result:INTEGER

    lnk := first_link
    {lnk = NULL}.until_do {
      (safe_equal.test element with (lnk.item)).if {
        result := result + 1
      }
      lnk := lnk.next
    }
    result
  )

  - fast_occurrences element:V :INTEGER <-
  ( + lnk:LINKED_LIST_NODE V
    + result:INTEGER

    lnk := first_link
    {lnk = NULL}.until_do {
      (element = lnk.item).if {
        result := result + 1
      }
      lnk := lnk.next
    }
    result
  )

  - all_default:BOOLEAN <-
  ( + l:LINKED_LIST_NODE V
    + d:V
    + result:BOOLEAN

    result := TRUE
    l := first_link
    {(! result) || {l = NULL}}.until_do {
      result := l.item = d
      l := l.next
    }
    result
  )

  - remove_last <-
  ( + link:LINKED_LIST_NODE V
    (upper = 0).if {
      first_link := NULL
      last_link  := NULL
      mem_lnk := NULL
      mem_idx := upper := -1
    } else {
      link := last_link
      last_link := link.previous
      last_link.set_next NULL
      (mem_idx = upper).if {
        mem_idx := 0
        mem_lnk := first_link
      }
      upper := upper - 1
    }
  )

  - replace_all old_value:V with new_value:V <-
  ( + safe_equal:SAFE_EQUAL V
    lower.to upper do { i:INTEGER
      (safe_equal.test (item i) with old_value).if {
        put new_value to i
      }
    }
  )

  - fast_replace_all old_value:V with new_value:V <-
  (
    lower.to upper do { i:INTEGER
      (item i = old_value).if {
        put new_value to i
      }
    }
  )

  - reverse <-
  ( + temp:V
    + low:LINKED_LIST_NODE V
    + high:LINKED_LIST_NODE V
    + i:INTEGER
    low  := first_link
    high := last_link
    i := count / 2
    ? {(i > 0) -> ((low != NULL) & (high != NULL))}
    ? {(i > 0) -> ((low != high) & (low.previous != high))}
    {i = 0}.until_do {
      temp := low.item
      low.set_item (high.item)
      high.set_item temp
      low  := low.next
      high := high.previous
      i    := i - 1
    }
  )

Private
  - go_item index:INTEGER <-
  [ 
    ? {valid_index index}
    ? {mem_idx >= 0}
    ? {mem_lnk != NULL}
  ]
  (
    (index = mem_idx).if {
      // good.
    }.elseif {index > mem_idx} then {
      ((upper - index) < (index - mem_idx)).if {
        mem_idx := upper
        mem_lnk := last_link
        {index = mem_idx}.until_do {
          mem_lnk := mem_lnk.previous
          mem_idx := mem_idx - 1
        }
      } else {
        {index = mem_idx}.until_do {
          mem_lnk := mem_lnk.next
          mem_idx := mem_idx + 1
        }
      }
    }.elseif {(mem_idx - index) < (index - 1)} then {
      {index = mem_idx}.until_do {
        mem_lnk := mem_lnk.previous
        mem_idx := mem_idx - 1
      }
    } else {
      mem_idx := 0
      mem_lnk := first_link
      {index = mem_idx}.until_do {
        mem_lnk := mem_lnk.next
        mem_idx := mem_idx + 1
      }
    }
  )
  [ 
    ? {mem_idx = index}
    ? {mem_lnk != NULL}
  ]

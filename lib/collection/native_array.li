Header
  + name := Strict NATIVE_ARRAY V; 
  /*
   Native array of collection library. ( C array)
   This class gives access to the lowest level for arrays. As any low level array, you can
   get high performances with NATIVE_ARRAYs, but you loose most valid bounds checks (as
   you can do in plain C code for example).
  */
  
Insert
  - parent_clone: CLONE := CLONE
  
Public
  
  // Basic features:

  - object_size:INTEGER := 0; // For detect error.

  - element_sizeof:INTEGER <-
  // The size in number of bytes for type `E'.
  ( + result:INTEGER
    (V.is_expanded_type).if {
      result := V.object_size
    } else {
      result := POINTER.object_size
    }
    result
  )
  
  - malloc:INTEGER
  - calloc_intern nb_elements:INTEGER :NATIVE_ARRAY V <-
  // Allocate a new array of 'nb_elements' of type `E'.
  // The new array is initialized with default values.
  [ //BSBS Old
    -? {nb_elements > 0}
  ]
  ( + capacity:INTEGER
    + p:POINTER
    + result  :NATIVE_ARRAY V

    capacity := nb_elements * element_sizeof
    p := `malloc(@capacity)`:POINTER
    /*
    malloc := malloc + 1
    (malloc > 1000).if {
      "Malloc Memory: ".print; type_name.print; malloc.print
      '\n'.print
      crash_with_message "Fuite !!!"
    };*/
    
    //`printf("Malloc\n")`
    //p := MEMORY.alloc_dynamic capacity; // ANDROID
    result := CAST POINTER TO (NATIVE_ARRAY V).on p
    result
  )
  [ //BSBS Old
    +? {Result != NULL}
  ]

  - create nb_elements:INTEGER :NATIVE_ARRAY V <-
  // Allocate a new array of `nb_elements' of type `E'.
  // The new array is initialized with default values.
  [ //BSBS Old
    -? {nb_elements > 0}
  ]
  ( + result:NATIVE_ARRAY V

    result:=calloc_intern nb_elements
    result.clear_all (nb_elements-1)
    result
  )
  [ //BSBS Old
//    +? {Result.all_default (nb_elements-1)}
  ]
  
  //- free <- `free(@Self)`
  
  - realloc_intern old_nb_elts:INTEGER with new_nb_elts:INTEGER :NATIVE_ARRAY V <-
  ( + old_ptr,new_ptr:POINTER
    + new_cap:INTEGER

    old_ptr := CAST (NATIVE_ARRAY V) TO POINTER.on Self
    new_cap := new_nb_elts * element_sizeof
    new_ptr := `realloc(@old_ptr,@new_cap)`:POINTER
    CAST POINTER TO (NATIVE_ARRAY V).on new_ptr    
  )
  
  - update_size (ptr:NATIVE_ARRAY V,old_c:INTEGER) new c:INTEGER :(NATIVE_ARRAY V,INTEGER) <-
  ( + r:NATIVE_ARRAY V
    (ptr = NULL).if {
      r := calloc_intern c
    } else {
      r := ptr.realloc_intern old_c with c
    }
    r,c
  )
  
  - nb_realloc:INTEGER
  - realloc old_nb_elts:INTEGER with new_nb_elts:INTEGER :NATIVE_ARRAY V <-
  // Assume Current is a valid NATIVE_ARRAY in range
  // [0 .. `old_nb_elts'-1]. Allocate a bigger new array in
  // range [0 .. `new_nb_elts'-1].
  // Old range is copied in the new allocated array.
  // New items are initialized with default values.
  [ //BSBS Old
    -? {Self != NULL}
    -? {old_nb_elts > 0}
    -? {old_nb_elts < new_nb_elts}
  ]
  ( + new:NATIVE_ARRAY V
    new := realloc_intern old_nb_elts with new_nb_elts
    new.clear old_nb_elts to (new_nb_elts - 1)
    new
  )
  [ //BSBS Old
    +? {Result != NULL}
  ]

  - first:V <- at 0

  - second:V <- at 1

  - at index:INTEGER :V <-
  // To read an item from this memory address.
  // Assume that you know what you are doing and where you go in memory, before or after.
  (
    `10`
  )
  
  - at index:INTEGER put element:V <-
  // To write an item.
  // Assume that `calloc' is already done and that the `index' is valid.
  (
    force_put element to index
  )
  
  - put element:V to index:INTEGER <-
  // BSBS -> DOM Pour que je puisse travailler ...
  (
    force_put element to index
  )
  
  - swap i:INTEGER with j:INTEGER <-
  ( 
    at i put (    at j)
    at j put (Old at i)
  )
  
  - quick_sort cmp:{ (V,V); BOOLEAN} from low:INTEGER to up:INTEGER <-
  ( + i:INTEGER
    + pivot:V
    (low < up).if {
      pivot := at up
      i := low
      low.to (up-1) do { j:INTEGER
        (cmp.value (at j,pivot)).if {
          swap i with j
          i := i + 1
        }
      }
      swap i with up
      quick_sort cmp from low to (i - 1)
      quick_sort cmp from (i + 1) to up
    }
  )
  
  - quick_sort_upper up:INTEGER <- quick_sort { (a,b:V); a < b} from 0 to up
  
  // Displacement

  - Self:SELF '+' Left 80 other:INTEGER :NATIVE_ARRAY V <-
  // other is in element index
  ( + ptr:POINTER

    ptr := to_pointer
    ptr := ptr + other * element_sizeof
    CAST POINTER TO (NATIVE_ARRAY V).on ptr
  )
  
  - Self:SELF '&' Left 80 other:INTEGER :NATIVE_ARRAY V <-
  // other is in element index
  ( + ptr:POINTER

    ptr := to_pointer
    ptr := ptr & other
    CAST POINTER TO (NATIVE_ARRAY V).on ptr
  )
  
  - Self:SELF '-' Left 80 other:INTEGER :NATIVE_ARRAY V <-
  // other is in element index
  ( + ptr:POINTER

    ptr := to_pointer
    ptr := ptr - other * element_sizeof
    CAST POINTER TO (NATIVE_ARRAY V).on ptr
  )
  
  - Self:SELF '#-' Left 80 other:SELF :INTEGER <-
  // other is in element index
  ( + ptr:POINTER

    ptr := to_pointer
    ptr := ptr - other.to_pointer
    CAST POINTER TO INTEGER.on ptr
  )

  // Comparison:

  - memcmp other:NATIVE_ARRAY V until up:INTEGER :BOOLEAN <-
  // True if all elements in range [0..up] are
  // identical using `equal'. Assume Current and `other'
  // are big enough.
  // See also `fast_memcmp'.
  ( + i:INTEGER
    i := up
    {(i >= 0) && {safe_equal (at i,other.at i)}}.while_do {
      i := i - 1
    }
    i < 0
  )

  - slice_memcmp (at:INTEGER,other:NATIVE_ARRAY V,other_lower,other_upper:INTEGER) :BOOLEAN <-
  // True if all elements in range [0 .. `other_upper' - `other_lower'] are identical
  // to the elements in range [`other_lower' .. `other_upper'] of `other' using
  // `is_equal'. Assume `Current' and `other' are big enough.
  // See also `slice_fast_memcmp'.
  [ //BSBS Old
    -? {at >= 0}
    -? {other_lower >= 0}
    -? {other_upper >= other_lower - 1}
    -? {(other_upper >= other_lower) ->> {other.is_not_null}}
  ]
  ( + i:INTEGER
    i := other_upper - other_lower
    {(i >= 0) && {safe_equal (at (at + i),other.at (other_lower + i))}}.while_do {
      i := i - 1
    }
    i < 0
  )

  - fast_memcmp other:NATIVE_ARRAY V until up:INTEGER :BOOLEAN <-
  // Same jobs as `memcmp' but uses infix `=' instead `equal'.
  [ //BSBS Old
    //-? {(capa > 0) ->> {other.is_not_null}}
  ]
  ( + i:INTEGER

    i := up
    {(i >=0 ) && {at i = other.at i}}.while_do {
      i := i - 1
    }
    i < 0
  )

  - slice_fast_memcmp (at:INTEGER, other:NATIVE_ARRAY V, other_lower,other_upper:INTEGER) :BOOLEAN <-
  // Same jobs as `slice_memcmp' but uses infix "=" instead of `is_equal'.
  [ //BSBS Old
    -? {at >= 0}
    -? {other_lower >= 0}
    -? {other_upper >= other_lower - 1}
    -? {(other_upper >= other_lower) ->> {other.is_not_null}}
  ]
  ( + i:INTEGER

    i := other_upper - other_lower
    {(i < 0) || {at (at + i) != other.at (other_lower + i)}}.until_do {
      i := i - 1
    }
    i < 0
  )

  - deep_memcmp other:NATIVE_ARRAY V until capa:INTEGER :BOOLEAN <-
  // Same jobs as `memcmp' but uses `is_deep_equal' instead `equal'.
  [ //BSBS Old
    -? {(capa > 0) ->> {other.is_not_null}}
  ]
  ( + result:BOOLEAN;  // BEN : A REVOIR, il y a + efficace...
    not_yet_implemented
    /*+ e1,e2:V
    + i:INTEGER

    result := TRUE
    i := capa - 1
    {(result = FALSE) || {i < 0}}.until_do {
      e1 := at i
      e2 := other.at i
      (e1 != e2).if {
        ((e1 != NULL) && {e2 != NULL}).if {
          (! e1.is_deep_equal e2).if {
            result := FALSE
          }
        } else {
          result := FALSE
        }
      }
      i := i - 1
    };*/
    result
  )

  - slice_deep_memcmp (at:INTEGER,other:NATIVE_ARRAY V,other_lower,other_upper:INTEGER) :BOOLEAN <-
  // Same jobs as `slice_memcmp' but uses `is_deep_equal' instead of `is_equal'.
  [ //BSBS Old
    -? {at >= 0}
    -? {other_lower >= 0}
    -? {other_upper >= other_lower - 1}
    -? {(other_upper >= other_lower) ->> {other.is_not_null}}
  ]
  ( + result:BOOLEAN
    not_yet_implemented
    /*
    + i:INTEGER
    + e1,e2:V

    i := other_upper - other_lower
    result := TRUE
    {(! result) || {i < 0}}.until_do {
      e1 := at i
      e2 := other.at i
      (e1 = e2).if {
      }.elseif {e1 != NULL} then {
        (e2 != NULL).if {
          result := e1.is_deep_equal e2
        } else {
          result := FALSE
        }
      } else {
        result := FALSE
      }
      i := i - 1
    };*/
    result
  )

  // Searching:

  - first_index_of element:V until up:INTEGER :INTEGER <-
  // Give the index of the first occurrence of `element' using
  // `==' for comparison.
  // Answer `upper + 1' when `element' is not inside.
  // See also `fast_index_of', `reverse_index_of'.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + idx:INTEGER

    {(idx > up) || {safe_equal (element,at idx)}}.until_do        {
      idx := idx + 1
    }
    idx
  )

  - index_of (element:V,start_index:INTEGER) until up:INTEGER :INTEGER <-
  // Using `is_equal' for comparison, gives the index of the first occurrence of `element'
  // at or after `start_index'. Answer `upper + 1' when the search fail.
  // See also `fast_index_of', `reverse_index_of'.
  [ //BSBS Old
    -? {start_index >= 0}
    -? {start_index <= up}
  ]
  ( + result:INTEGER

    result := start_index
    {(result > up) || {safe_equal (element,at result)}}.until_do {
      result := result + 1
    }
    result
  )
  [ //BSBS Old
    +? {Result.in_range start_index to (up + 1)}
    +? {(Result <= up) ->> {safe_equal (element,at Result)}}
  ]

  - reverse_index_of element:V from up:INTEGER :INTEGER <-
  // Give the index of the first occurrence of `element' using
  // `==' for comparison, from upper to lower.
  // Answer -1 when `element' is not inside.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + idx:INTEGER

    idx := up
    {(idx < 0) || {safe_equal (element,at idx)}}.until_do        {
      idx := idx - 1
    }
    idx
  )
  [ //BSBS Old
    +? {Result.in_range (-1) to up}
    +? {(Result > 0) ->> {safe_equal (element, at Result)}}
  ]

  - fast_index_of (element:V,start_index:INTEGER) until up:INTEGER :INTEGER <-
  // Using basic `=' for comparison, gives the index of the first occurrence of
  // `element' at or after `start_index'. Answer `up + 1' when the search fail.
  // See also `index_of', `reverse_index_of'.
  [ //BSBS Old
    -? {start_index >= 0}
    -? {start_index <= up}
  ]
  ( + result:INTEGER

    result := start_index
    {(result > up) || {element = at result}}.until_do {
      result := result + 1
    }
    result
  )
  [ //BSBS Old
    +? {Result.in_range start_index to (up + 1)}
    +? {(Result <= up) ->> {element = at Result}}
  ]

  - fast_reverse_index_of element:V from up:INTEGER :INTEGER <-
  // Same as `reverse_index_of' but use basic `=' for comparison.
  // Search is done in reverse direction, which means from `up' down to the
  // `0'. Answer `-1' when the search fail.
  // See also `reverse_index_of', `index_of'.
  [
    -? {up >= -1}
  ]
  ( + idx:INTEGER

    idx := up
    {(idx < 0) || {element = at idx}}.until_do {
      idx := idx - 1
    }
    idx
  )
  [ //BSBS Old
    +? {Result.in_range (-1) to up}
    +? {(Result > 0) ->> {element = at Result}}
  ]

  - fast_first_index_of element:V until up:INTEGER :INTEGER <-
  // Same as `index_of' but use basic `=' for comparison.
  // `0'. Answer `up + 1' when the search fail.
  // See also `fast_index_of', `reverse_index_of'.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + idx:INTEGER

    {(idx > up) || {element = at idx}}.until_do {
      idx := idx + 1
    }
    idx
  )
  [ //BSBS Old
    +? {Result.in_range 0 to (up + 1)}
    +? {(Result <= up) ->> {element = at Result}}
  ]

  - has element:V until up:INTEGER :BOOLEAN <-
  // Look for `element' using `==' for comparison.
  // Also consider `has' to choose the most appropriate.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + result:BOOLEAN
    + i:INTEGER

    i := up
    {(result) || {i < 0}}.until_do {
      result := safe_equal (element,at i)
      i := i - 1
    }
    result
  )

  - fast_has element:V until up:INTEGER :BOOLEAN <-
  // Look for `element' using basic `=' for comparison.
  // Also consider `has' to choose the most appropriate.
  [
    -? {up >= -1}
  ]
  ( + i:INTEGER
    i := up
    {(i < 0) || {element = at i}}.until_do {
      i := i - 1
    }
    i >= 0
  )

  // Removing:

  - remove_first up:INTEGER <-
  // Assume `up' is a valid index.
  // Move range [1 .. `up'] by 1 position left.
  [ //BSBS Old
    -? {up >= 0}
  ]
  ( + i:INTEGER
    {i = up}.until_do {
      at i put (at (i + 1))
      i := i + 1
    }
  )

  - remove index:INTEGER until up:INTEGER <-
  // Assume `up' is a valid index.
  // Move range [`index' + 1 .. `up'] by 1 position left.
  [ //BSBS Old
    -? {index >= 0}
    -? {index <= up}
  ]
  ( + i:INTEGER

    i := index
    {i = up}.until_do {
      at i put (at (i + 1))
      i := i + 1
    }
  )

  // Replacing:

  - replace_all old_value:V with new_value:V until up:INTEGER <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using `==' for comparison.
  // See also `fast_replace_all' to choose the apropriate one.
  [ //BSBS Old
    -? {up >= -1}
  ]
  (
    up.downto 0 do { i:INTEGER
      (safe_equal (old_value,(at i))).if {
        at i put new_value
      }
    }
  )

  - fast_replace_all old_value:V with new_value:V until up:INTEGER <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using basic `=' for comparison.
  // See also `replace_all' to choose the apropriate one.
  [ //BSBS Old
    -? {up >= -1}
  ]
  (
    up.downto 0 do { i:INTEGER
      (old_value = at i).if {
        at i put new_value
      }
    }
  )

  // Adding:
  
  - copy_inc src:NATIVE_ARRAY V to dest:INTEGER until src_upper:INTEGER <-
  // Copy range [0 .. `src_upper'] of `src' to range
  // [`dest' .. `dest + src_upper'] of `Self'.
  // No subscript checking.
  ( + i1, i2:INTEGER
    i1 := dest
    {i2 <= src_upper}.while_do {
      at i1 put (src.at i2)
      i2 := i2 + 1
      i1 := i1 + 1
    }
  )
  
  - copy_dec src:NATIVE_ARRAY V to dest:INTEGER until src_upper:INTEGER <-
  // Copy range [0 .. `src_upper'] of `src' to range
  // [`dest' .. `dest + src_upper'] of `Self'.
  // No subscript checking.
  ( + i1, i2:INTEGER
    i2 := src_upper
    i1 := dest + src_upper
    {i2 >= 0}.while_do {      
      at i1 put (src.at i2)
      i2 := i2 - 1
      i1 := i1 - 1
    }
  )

  - copy src:NATIVE_ARRAY V to dest:INTEGER until src_capacity:INTEGER <-
  // Copy range [0 .. `src_capacity - 1'] of `src' to range
  // [`dest' .. `dest + src_capacity - 1'] of `Self'.
  // No subscript checking.
  [ //BSBS Old
    -? {dest >= 0}
    -? {src_capacity >= 0}
  ]
  ( + i1, i2:INTEGER

    i1 := dest
    {i2 = src_capacity}.until_do {
      at i1 put (src.at i2)
      i2 := i2 + 1
      i1 := i1 + 1
    }
  )

  - slice_copy src:NATIVE_ARRAY V to dest:INTEGER
  from src_min:INTEGER to src_max:INTEGER <-
  // Copy range [`src_min' .. `src_max'] of `src' to range
  // [`at' .. `at + src_max - src_min - 1'] of `Current'.
  // No subscript checking.
  [ //BSBS Old
    -? {dest >= 0}
    -? {src_min <= src_max + 1}
    -? {(src != Self) | (dest != src_min)}
  ]
  ( + i1, i2:INTEGER

    i1 := dest
    i2 := src_min
    {i2 > src_max}.until_do {
      at i1 put (src.at i2)
      i2 := i2 + 1
      i1 := i1 + 1
    }
  )
  
  - copy src:INTEGER n n:INTEGER to dst:INTEGER <-
  ( 
    0.to (n-1) do { i:INTEGER
      at (dst+i) put (at (src+i))
    }
  )
  
  // Other:

  - set_all_with v:V until up:INTEGER <-
  // Set all elements in range [0 .. up] with
  // value `v'.
  [ //BSBS Old
    -? {up >= -1}
  ]
  (
    up.downto 0 do { i:INTEGER
      at i put v
    }
  )

  - set_slice_with v:V from lower:INTEGER until up:INTEGER <-
  // Set all elements in range [`lower' .. `up'] with value `v'.
  [ //BSBS Old
    -? {lower >= 0}
    -? {up >= lower - 1}
  ]
  ( + i:INTEGER
    i := lower
    {i > up}.until_do {
      at i put v
      i := i + 1
    }
  )

  - clear_all up:INTEGER <-
  // Set all elements in range [0 .. `up'] with
  // the default value.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + v:V

    up.downto 0 do { i:INTEGER
      at i put v
    }
  )

  - clear lower:INTEGER to up:INTEGER <-
  // Set all elements in range [`lower' .. `up'] with
  // the default value
  [ //BSBS Old
    -? {lower >= 0}
    -? {up >= lower}
  ]
  ( + v:V

    lower.to up do { i:INTEGER
      at i put v
    }
  )

  - copy_from model:NATIVE_ARRAY V until up:INTEGER <-
  // Assume `up' is a valid index both in Current and `model'.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( /*+ sz:INTEGER
    sz := element_sizeof
    `memcpy(@Self,@model,(@up+1)*sz)`;*/ // BSBS: Voir les perfs !!!    
    0.to up do { i:INTEGER
      at i put (model.at i)
    }
  )

  - deep_twin_from capa:INTEGER :NATIVE_ARRAY V <-
  // To implement `deep_twin'. Allocate a new array of
  // `capa' initialized with `deep_twin'.
  // Assume `capa' is valid both in Current and `model'.
  [ //BSBS Old
    -? {capa >= 0}
  ]
  ( + result:NATIVE_ARRAY V
    not_yet_implemented
    /*
    + element:V
    
    (capa > 0).if {
      result := calloc_intern capa
      (capa - 1).downto 0 do { i:INTEGER
        element := at i
        (element != NULL).if {
          element := element.deep_twin
        }
        result.put element to i
      }
    };*/
    result
  )

  - move lower:INTEGER to up:INTEGER by offset:INTEGER <-
  // Move range [`lower' .. `up'] by `offset' positions.
  // Freed positions are not initialized to default values.
  [ //BSBS Old
    -? {lower >= 0}
    -? {up >= lower}
    -? {lower + offset >= 0}
  ]
  (
    (offset != 0).if {
      (offset < 0).if {
        lower.to up do { i:INTEGER
          at (i + offset) put (at i)
        }
      } else {
        up.downto lower do { i:INTEGER
          at (i + offset) put (at i)
        }
      }
    }
  )

  - occurrences element:V until up:INTEGER :INTEGER <-
  // Number of occurrences of `element' in range [0..up]
  // using `equal' for comparison.
  // See also `fast_occurrences' to chose the apropriate one.
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + count:INTEGER
    up.downto 0 do { i:INTEGER
      (safe_equal (element,at i)).if {
        count := count + 1
      }
    }
    count
  )

  - slice_occurrences element:V from lower:INTEGER until up:INTEGER :INTEGER <-
  // Number of occurrences of `element' in range [`lower' .. `up'] using
  // `is_equal' for comparison.
  // See also `slice_fast_occurrences' to chose the apropriate one.
  [ //BSBS Old
    -? {lower >= 0}
    -? {up >= lower - 1}
  ]
  ( + i,result:INTEGER

    i := lower
    {i > up}.until_do {
      (safe_equal (element,at i)).if {
        result := result + 1
      }
      i := i + 1
    }
    result
  )

  - fast_occurrences element:V until up:INTEGER :INTEGER <-
  // Number of occurrences of `element' in range [0..up]
  // using basic "=" for comparison.
  // See also `fast_occurrences' to chose the apropriate one.
  [
    -? {up >= -1}
  ]
  ( + count:INTEGER
    up.downto 0 do { i:INTEGER
      (element = at i).if {
        count := count + 1
      }
    }
    count
  )

  - slice_fast_occurrences element:V from lower:INTEGER until up:INTEGER :INTEGER <-
  // Number of occurrences of `element' in range [`lower' .. `up']
  // using basic "=" for comparison.
  // See also `slice_occurrences' to chose the apropriate one.
  [ //BSBS Old
    -? {lower >= 0}
    -? {up >= lower - 1}
  ]
  ( + i,result:INTEGER

    i := lower
    {i > up}.until_do {
      (element = at i).if {
        result := result + 1
      }
      i := i + 1
    }
    result
  )

  - all_default up:INTEGER :BOOLEAN <-
  // Do all items in range [0 .. `up'] have their type's
  // default value?
  [ //BSBS Old
    -? {up >= -1}
  ]
  ( + result:BOOLEAN
    + model:V
    ? {up >= -1}
    result := TRUE
    up.downto 0 do { i:INTEGER
      (model != at i).if {
        result := FALSE
      }
    }
    result
  )

  - slice_default lower:INTEGER to up:INTEGER :BOOLEAN <-
  // Do all items in range [`lower' .. `up'] have their type's default value?
  // Note: for non Void items, the test is performed with the `is_default' predicate.
  [ //BSBS Old
    -? {lower >= 0}
    -? {up >= lower - 1}
  ]
  ( + i:INTEGER
    + v:V
    + result:BOOLEAN

    result := TRUE
    i := lower
    {(i > up) || {! result}}.until_do {
      result := at i = v
      i := i + 1
    }
    result
  )

  // Interfacing with C:

  - is_null:BOOLEAN <- (to_pointer.is_null)

  - is_not_null:BOOLEAN <- (to_pointer.is_not_null)

  - to_external:POINTER <- to_pointer
  // Gives access to the C pointer on the area of storage.

  // Guru Section

  - println <- `puts(@Self)`

  - force_put element:V to index:INTEGER <-
  // Used in Memory count: not to use directly without caution !
  (
    `9`
  )
    
  - quick_sort_from low:INTEGER to up:INTEGER with cmp:{ (V,V); BOOLEAN} <-
  ( + i, p:INTEGER
    + pivot, tmp:INTEGER
    (up > low).if {
      pivot := (low + up) >> 1
      swap pivot with low
      p := low
      (low+1).to up do { i:INTEGER
        (cmp.value (at low,at i)).if {
          p := p + 1
          swap i with p
        }
      }
      swap p with low
      quick_sort_from low to (p - 1) with cmp
      quick_sort_from (p + 1) to up with cmp
    }
  )
  
  - shift_right low:INTEGER to up:INTEGER <-
  // Move slice low to up by one to the right.
  // Assume up + 1 is a valid index.  
  [
    ? {low >= 0}
    ? {low <= (up + 1)}
  ]
  ( + i:INTEGER
    i := up
    {i < low}.until_do {
      at (i + 1) put (at i)
      i := i - 1
    }
  )
  
  - shift_left low:INTEGER to up:INTEGER <-
  // Move slice low to up by one to the left.
  // Assume up is a valid index in case of a non-empty slice.  
  [
    ? {low > 0}
    ? {low <= (up + 1)}
  ]
  ( + i:INTEGER
    i := low - 1
    {i < up}.while_do {
      at i put (at (i + 1))
      i := i + 1
    }
  )
  

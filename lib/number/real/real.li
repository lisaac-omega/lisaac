Header
  + name := Expanded REAL;
  /*Generic real number. DCDC generic ou float ?? BSBS:generic!*/
  - type    := `float`;
  - default := 0.0;
  - export := REAL_32, REAL_64, REAL_80,
  REAL_16_16,  REAL_24_8,  REAL_26_6,
  UREAL_16_16, UREAL_24_8, UREAL_26_6;
  - lip     <-
  (
    add_lib "-lm";
  );

Insert
  - inherit_numeric:NUMERIC := NUMERIC

Public

  - Self:SELF '+'  Left 80 <> other:SELF :SELF <- `@Self + @other`:SELF
  
  - Self:SELF '%'  Left 90 other:SELF :SELF <- `fmodf(@Self,@other)`:SELF
  
  - bound_test low:INTEGER_64 to up:UINTEGER_64 :BOOLEAN <-
  (
    TRUE
  )

  - pi   :SELF <- 3.14159265358979323846
  // Pi number
  
  - two_pi:SELF <- pi * 2.0
  
  - pi_two:SELF <- pi / 2.0
  
  - tan  :SELF <- `tan(@Self)`:SELF

  - atan :SELF <- `atan(@Self)`:SELF
  // Arctangent
  
  - atan2 dx:SELF :SELF <- `atan2(@Self,@dx)`:SELF
  
  - sqrt :SELF <-
  [ ? {Self >= 0.0}; ]
  `sqrt(@Self)`:SELF
  // Square root

  - log  :SELF <-
  [ ? {Self > 0.0}; ]
  `log(@Self)`:SELF
  // Logarithm

  - sin (Self:SELF) :SELF <- `sin(@Self)`:SELF
  // Sinus
  
  - asin :SELF <- `asin(@Self)`:SELF
  // Arc Sinus

  - cos (Self:SELF) :SELF <- `cos(@Self)`:SELF
  // Cosinus
  
  - acos  :SELF <- `acos(@Self)`:SELF
  // Arc Cosinus

  - pow e:SELF :SELF <- `pow(@Self,@e)`:SELF
  - exp:SELF <- `exp(@Self)`:SELF
  // Power

  - Self:SELF '**' Right 99 e:SELF :SELF <-
  // Power
  (
    Self.pow e
  )

  - Self:SELF '^' Right 99 e:SELF :SELF <-
  // Power
  (
    Self.pow e
  )
    
  // Convertion format with test.

  - floor:INTEGER <-
  // Greatest integral value no greater than Current.
  (
    `floor(@Self)`:INTEGER
    //to_raw_integer
  )
  
  - ceil:SELF <- `ceil(@Self)`:SELF
  
  - ceiling:INTEGER <-
  // Smallest integral value no smaller than Current.
  (
    (Self + 0.9999).floor
  )

  - round:INTEGER <-
  // Rounded integral value.
  (
    (Self + 0.5).floor
  )

  - truncated_to_integer:INTEGER <- floor
  // Integer part (largest absolute value no greater than Current).

  // Comparaison.

  - Self:SELF '~=' (other,delta:SELF) :BOOLEAN <-
  // Equal, close to 0.001
  (
    (Self - other).abs <= delta
  )
  
  - Self:SELF '!~=' (other,delta:SELF) :BOOLEAN <- ! (Self ~= (other,delta))
    
  // Print.

  - append_in b:STRING_BUFFER <-
  // Append `Self' decimal representation in `b' with 4 decimal
  (
    append_in b decimal 4
  )

  - append_in b:STRING_BUFFER format n:INTEGER decimal d:INTEGER <-
  (
    append_in b format n with ' ' decimal d
  )

  - append_in b:STRING_BUFFER format n:INTEGER with c:CHARACTER decimal d:INTEGER <-
  // String of the number in base 10 with `c' replacing blanck
  [
    -? {n >= 3}
  ]
  ( + old_count:INTEGER
    old_count := b.count
    append_in b decimal d
    b.insert c to old_count on (n - (b.count - old_count))
  )

  - append_in b:STRING_BUFFER decimal n:INTEGER <-
  // String of the number in base 10 with 4 decimal
  ( + val:SELF
    + val_10:INTEGER
    + char:CHARACTER
    + i:INTEGER

    get_map Self
    // Sign.
    (sign).if {
      val := Self
    } else {
      b.add_last '-'
      val := - Self
    }
    (is_zero).if {      
      b.add_last '0'
    }.elseif {is_infinite} then {
      b.append "inf"
    }.elseif {is_nan} then {
      b.append "nan"
    } else {
      // Value case = 1.mantisse x 2^(exp-127)
      (val > INTEGER.maximum.to_real_32).if {
        scientific_append_in b
      } else {
        val_10 := val.to_integer
        val_10.append_in b
        val := val - val_10
        (n != 0).if {
          b.add_last '.'
          i := n
          {(val != 0) && {i > 0}}.while_do {
            val := val * 10
            val_10 := val.to_integer
            char := val_10.decimal_digit
            b.add_last char
            val := val - val_10
            i := i - 1
          }
          b.extend_multiple '0' by i
        }
      }
    }
  )

  - scientific_append_in b:STRING_BUFFER <-
 // Scientific number representation
  ( + val:SELF
    + val_10:INTEGER
    + exp_10:INTEGER
    + char:CHARACTER

    get_map Self
    // Sign.
    (sign).if {
      val := Self
    } else {
      b.add_last '-'
      val := - Self
    }
    (is_zero).if {
      // Zero case.
      b.add_last '0'
    }.elseif {is_infinite} then {
      // Infinite case.
      b.append "Infinite"
    }.elseif {is_nan} then {
      // Nan case.
      b.append "Nan"
    } else {
      // Value case.
      {val > 10}.while_do {
        val    := val / 10
        exp_10 := exp_10 + 1
      }
      {val < 0}.while_do {
        val    := val * 10
        exp_10 := exp_10 - 1
      }
      val_10 := val.to_integer
      char := val_10.decimal_digit
      b.add_last char
      b.add_last '.'
      val := val - val_10
      {val != 0}.while_do {
        val := val * 10
        val_10 := val.to_integer
        char := val_10.decimal_digit
        b.add_last char
        val := val - val_10
      }
      b.add_last 'E'
      exp_10.append_in b
    }
  )

  - append_in b:STRING_BUFFER format_c fmt:STRING <-
  ( + nc_buf,nc_fmt:NATIVE_ARRAY(CHARACTER)
    + old_count,cap:INTEGER

    old_count := b.count
    cap       := b.capacity - old_count
    nc_buf    := b.to_external + old_count
    nc_fmt    := fmt.to_external
    `snprintf(@nc_buf,@cap,@nc_fmt,@Self)`
    b.restore_after_external
  )

  - print_decimal s:INTEGER <-
  // print with `s' decimal
  (
    STRING.tmp { tmp:STRING_BUFFER
      append_in tmp decimal s
      tmp.print
    }
  )

  - print_int i:INTEGER decimal d:INTEGER <-
  (
    print_format (i+d+1) decimal d
  )

  - print_format s:INTEGER decimal d:INTEGER <-
  [
    -? {s > d}
  ]
  (
    print_format s with ' ' decimal d
  )

  - print_format s:INTEGER with c:CHARACTER decimal d:INTEGER <-
  [
    -? {s > d}
  ]
  (
    STRING.tmp { tmp:STRING_BUFFER
      append_in tmp format s with c decimal d
      tmp.print
    }
  )

  - print_format_c fmt:STRING <-
  (
    STRING.tmp { tmp:STRING_BUFFER
      append_in tmp format_c fmt
      tmp.print
    }
  )


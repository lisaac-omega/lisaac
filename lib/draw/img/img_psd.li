Header
  
  + name := IMG_PSD;
  
Inherit
  
  + parent_image:Expanded IMAGE
  
Public
  
  - name:STRING_ALIAS := "PSD - PhotoShop Document (Adobe)"
  
  + channel_count:INTEGER
  + bitdepth:INTEGER
  
  - test:BOOLEAN <-
  ( 
    rewind
    (get32be = 038_42_50_53h)    
  )
  
  - info:BOOLEAN <-
  ( + result:BOOLEAN
    rewind
    ((get32be = 038425053h) && {get16be = 1}).if {
      skip 6
      channel_count := get16be
      (channel_count.in_range 0 to 16).if {
        img_y := get32be
        img_x := get32be
        //"Size: ".print; img_x.print; 'x'.print; img_y.print; '\n'.print
        ((((bitdepth := get16be) = 8) || {bitdepth = 16}) && {get16be = 3}).if {
          // Make sure the color mode is RGB.
          // Valid options are:
          //   0: Bitmap
          //   1: Grayscale
          //   2: Indexed color
          //   3: RGB color  <--------- Ok !
          //   4: CMYK color
          //   7: Multichannel
          //   8: Duotone
          //   9: Lab color
          img_n := 4
          result := TRUE
        }
        //"Depth:".print; bitdepth.println
      }
    }
    result
  )

  - load req_comp:INTEGER :NATIVE_ARRAY UINTEGER_8 <-
  ( + pixel_count,compression:INTEGER
    + count, len:INTEGER
    + out:NATIVE_ARRAY UINTEGER_8
    + r:BOOLEAN

    r := info
    ? {r}
    skip get32be; // Skip the Mode Data.  (palette for indexed; other info.)    
    skip get32be; // Skip the image resources. (resolution, pen tool paths, etc)    
    skip get32be; // Skip the reserved data.

    // Find out if the data is compressed.
    // Known values:
    //   0: no compression
    //   1: RLE compressed
    compression := get16be
    (compression > 1).if {
      error := "bad compression"
      exit 0
    }
    // Create the destination image.
    pixel_count := img_x*img_y
    out := NATIVE_ARRAY UINTEGER_8.create (pixel_count * 4)
    
    // Finally, the image data.
    (compression != 0).if {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      //"Compress ok\n".print
      skip (img_y * channel_count * 2)
      //"channel_count:".print; channel_count.println
      // Read the RLE data by channel.
      0.to 3 do { channel:INTEGER
        + p:NATIVE_ARRAY UINTEGER_8
        p := out+channel
        (channel >= channel_count).if {
          + val:UINTEGER_8
          // Fill this channel with default data.
          val := (channel = 3).ok 255 or 0
          0.to (pixel_count-1) do { i:INTEGER
             p.at 0 put val
             p := p + 4
          }
        } else {
          // Read the RLE data.
          count := 0
          {count < pixel_count}.while_do {
            len := get8
            (len = 128).if {
              // No-op.
            }.elseif {len < 128} then {
              // Copy next len+1 bytes literally.
              len := len + 1
              count := count + len
              {len != 0}.while_do {
                p.at 0 put get8
                p := p + 4
                len := len - 1
              }
            }.elseif {len > 128} then {
              + val:UINTEGER_8
              // Next -len+1 bytes in the dest are replicated from next source byte.
              // (Interpret len as a negative 8-bit int.)
              len := len ^ 0FFh
              len := len + 2
              val := get8
              count := count + len
              {len != 0}.while_do {
                p.at 0 put val
                p := p + 4
                len := len - 1
              }
            }
          }
        }
      }
    } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit value for each pixel in the image.
      //"Pas compress\n".print
      // Read the data by channel.
      0.to 3 do { channel:INTEGER
        + p:NATIVE_ARRAY UINTEGER_8
        p := out + channel
        (channel >= channel_count).if {
          + val:UINTEGER_8
          // Fill this channel with default data.
          val := (channel = 3).ok 255 or 0
          0.to (pixel_count-1) do { i:INTEGER
            p.at (i*4) put val
          }
        } else {
          // Read the data.
          (bitdepth = 16).if {
            0.to (pixel_count-1) do { i:INTEGER
              p.at (i*4) put ((get16be >> 8).to_uinteger_8)
            }
          } else {
            0.to (pixel_count-1) do { i:INTEGER
              p.at (i*4) put get8
            }
          }
        }
      }
    }
    ((req_comp != 0) && {req_comp != 4}).if {
      out := convert_format out from 4 to req_comp
    }
    out
  )


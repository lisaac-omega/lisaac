Header
  + name := IMG_BMP;
  /*Microbite - Windobe BMP image*/
  
Inherit  
  + parent_image:Expanded IMAGE
  
Private
  
  - pal:NATIVE_ARRAY UINTEGER_8 := NATIVE_ARRAY UINTEGER_8.create 1024
  
Private
  
  + bpp:INTEGER
  + offset:INTEGER
  + hsz:INTEGER
  + mr:UINTEGER_32
  + mg:UINTEGER_32
  + mb:UINTEGER_32
  + ma:UINTEGER_32
  + all_a:UINTEGER_8
  
Public
  
  - name:STRING_ALIAS := "BMP - BitMaP (Microdobe & IBM)"
  
  - test:BOOLEAN <-
  ( 
    rewind
    (get8 = 'B') && {get8 = 'M'} && {
      get32le; // discard filesize
      get16le; // discard reserved (for appli. creation)
      get16le; // discard reserved (for appli. creation)
      offset := get32le; // discard data offset
      hsz := get32le
      (hsz = 12) || {hsz = 40} || {hsz = 56} || {hsz = 108} || {hsz = 124}
    }
  )
  
  - info:BOOLEAN <-
  ( 
    all_a := 255
    parse_header
  )

  - parse_header:BOOLEAN <-
  ( + result:BOOLEAN
    (test).if {
      (hsz = 12).if {
        img_x := get16le
        img_y := get16le
      } else {
        img_x := get32le
        img_y := get32le
      }
      //"Size: ".print; img_x.print; 'x'.print; img_y.println
      ((get16le != 1) || {(bpp := get16le) = 1}).if { 
        error := "bad BMP"
      } else {
        result := TRUE
        //"bpp=".print; bpp.println
        //"hsz=".print; hsz.println
        (hsz != 12).if {
          + compress:INTEGER
          compress := get32le
          //"compress: ".print; compress.println
          ((compress = 1) || {compress = 2}).if {
            crash_with_message "BMP type not supported: RLE"
          }
          get32le; // discard sizeof
          get32le; // discard hres
          get32le; // discard vres
          get32le; // discard colorsused
          get32le; // discard max important
          ((hsz = 40) || {hsz = 56}).if {
            (hsz = 56).if {
              mr := get32le
              mg := get32le
              mb := get32le
              ma := get32le
            }.elseif {(bpp = 16) || {bpp = 32}} then {
              mr := mg := mb := 0
              (compress = 0).if {
                (bpp = 32).if {
                  mr := 0FFh << 16
                  mg := 0FFh <<  8
                  mb := 0FFh <<  0
                  ma := 0FFh << 24
                  all_a := 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
                } else {
                  mr := 31 << 10
                  mg := 31 <<  5
                  mb := 31 <<  0
                }
              }.elseif {compress = 3} then {
                mr := get32le
                mg := get32le
                mb := get32le
                // not documented, but generated by photoshop and handled by mspaint
                ((mr = mg) && {mg = mb}).if { // ?!?!?
                  crash_with_message "bad BMP (1)"
                }
              } else {
                crash_with_message "bad BMP (2)"
              }
            }
          }.elseif {(hsz = 108) || {hsz = 124}} then {            
            mr := get32le
            mg := get32le
            mb := get32le
            ma := get32le
            get32le; // discard color space
            12.times { get32le; }; // discard color space parameters
            (hsz = 124).if {
              get32le; // discard rendering intent
              get32le; // discard offset of profile data
              get32le; // discard size of profile data
              get32le; // discard reserved
            }
          } else {
            crash_with_message "bad BMP (3)"
          }
        }
        img_n := (ma != 0).ok 4 or 3
      }
    }
    result
  )

  - load req_comp:INTEGER :NATIVE_ARRAY UINTEGER_8 <-
  ( + out:NATIVE_ARRAY UINTEGER_8
    + psize,width,pad,target:INTEGER
    + flip_vertically,r:BOOLEAN
    + v,v2:INTEGER
 
    all_a := 255
    r := parse_header
    ? {r}

    flip_vertically := img_y > 0
    img_y := img_y.abs

    (hsz = 12).if {
      (bpp < 24).if { psize := (offset - 14 - 24) / 3; }
    } else {
      (bpp < 16).if { psize := (offset - 14 - hsz) >> 2; }
    }
    ((req_comp != 0) && {req_comp >= 3}).if { // we can directly decode 3 or 4
      target := req_comp
    } else {
      target := img_n; // if they want monochrome, we'll post-convert
    }
    out := NATIVE_ARRAY UINTEGER_8.create (target * img_x * img_y)
    (bpp < 16).if {
      + z:INTEGER
      ((psize = 0) || {psize > 256}).if { 
        //STBI_FREE(out)
        crash_with_message "Corrupt BMP"
      }
      0.to (psize-1) do { i:INTEGER
        pal.at (i*4+2) put get8
        pal.at (i*4+1) put get8
        pal.at (i*4+0) put get8
        (hsz != 12).if { get8; }
        pal.at (i*4+3) put 255
      }
      skip (offset - 14 - hsz - psize * ((hsz = 12).ok 3 or 4))
      (bpp = 4).if {
        width := (img_x + 1) >> 1
      }.elseif {bpp = 8} then {
        width := img_x
      } else { 
        //STBI_FREE(out)
        crash_with_message "Corrupt BMP"
      }
      pad := (-width)&3
      0.to (img_y-1) do { j:INTEGER
        from 0 to (img_x-1) step 2 do { i:INTEGER
          v := get8
          (bpp = 4).if {
            v2 := v & 15
            v := v >> 4
          } else {
            v2 := 0
          }
          out.at z put (pal.at (v*4+0)); z := z + 1
          out.at z put (pal.at (v*4+1)); z := z + 1
          out.at z put (pal.at (v*4+2)); z := z + 1
          (target = 4).if {
            out.at z put 255; z := z + 1
          }
          (i+1 != img_x).if {
            v := (bpp != 8).ok v2 else { get8.to_integer }
            out.at z put (pal.at (v*4+0)); z := z + 1
            out.at z put (pal.at (v*4+1)); z := z + 1
            out.at z put (pal.at (v*4+2)); z := z + 1
            (target = 4).if {
              out.at z put 255; z := z + 1
            }
          }
        }
        skip pad
      }
    } else {
      + rshift,gshift,bshift,ashift,rcount,gcount,bcount,acount:INTEGER
      + z:INTEGER
      + easy:INTEGER
      + a:UINTEGER_8
      skip (offset - 14 - hsz)
      (bpp = 24).if { 
        width := 3 * img_x
      }.elseif {bpp = 16} then { 
        width := 2*img_x
      } else { /* bpp = 32 and pad = 0 */ 
        width := 0
      }
      pad := (-width) & 3
      (bpp = 24).if {
        easy := 1
      }.elseif {bpp = 32} then {
        ((mb = 0FFh) && {mg = 0FF00h} && {mr = 000FF0000h} && {ma = 0FF000000h}).if {
          easy := 2
        }
      }
      (easy = 0).if {
        ((mr = 0) || {mg = 0} || {mb = 0}).if { 
          //STBI_FREE(out)
          crash_with_message "bad masks"
        }
        // right shift amt to put high bit in position #7
        rshift := high_bit mr -7; rcount := bitcount mr
        gshift := high_bit mg -7; gcount := bitcount mg
        bshift := high_bit mb -7; bcount := bitcount mb
        ashift := high_bit ma -7; acount := bitcount ma
      }
      0.to (img_y-1) do { j:INTEGER
        (easy != 0).if {          
          0.to (img_x-1) do { i:INTEGER
            out.at (z+2) put get8
            out.at (z+1) put get8
            out.at (z+0) put get8
            z := z + 3
            a := (easy != 2).ok (255.to_uinteger_8) else { get8 }
            all_a := all_a | a
            (target = 4).if { 
              out.at z put a
              z := z + 1
            }
          }
        } else {      
          + val:UINTEGER_32
          0.to (img_x-1) do { i:INTEGER
            (bpp = 16).if { val := get16le; } else { val := get32le; }
            out.at z put (shiftsigned (val & mr) shift rshift bits rcount); z := z + 1
            out.at z put (shiftsigned (val & mg) shift gshift bits gcount); z := z + 1
            out.at z put (shiftsigned (val & mb) shift bshift bits bcount); z := z + 1
            a := (ma = 0).ok (255.to_uinteger_8) else { shiftsigned (val & ma) shift ashift bits acount }
            all_a := all_a | a
            (target = 4).if {
              out.at z put (a.to_uinteger_8); z := z + 1
            }
          }
        }
        skip pad
      }
    }
   
    // if alpha channel is all 0s, replace with all 255s
    ((target = 4) && {all_a = 0}).if {
      (4*img_x*img_y-1).downto 0 by 4 do { i:INTEGER
        out.at i put 255
      }
    }
    (flip_vertically).if {
      + t:UINTEGER_8
      + p1,p2:NATIVE_ARRAY UINTEGER_8
      0.to (img_y>>1 - 1) do { j:INTEGER
        p1 := out +          j *img_x*target
        p2 := out + (img_y-1-j)*img_x*target
        0.to (img_x*target-1) do { i:INTEGER; // BSBS: Mettre un swap
          t := p1.at i
          p1.at i put (p2.at i)
          p2.at i put t
        }
      }
    }

    ((req_comp != 0) && {req_comp != target}).if {
      out := convert_format out from target to req_comp
    }
    out
  )
  
  - write filename:STRING_ALIAS to (x,y:INTEGER) format comp:INTEGER img data:NATIVE_ARRAY UINTEGER_8 :BOOLEAN <-
  ( + pad:INTEGER
    + f:POINTER
    
    f := FILE_UTILS.open_write filename
    // Header.
    pad := (-x*3) & 3
    put8 ('B'.to_uinteger_8) to f
    put8 ('M'.to_uinteger_8) to f
    put32 (14+40+(x*3+pad)*y) to f
    put32 0; // Reserved.
    put32 (14+40) to f
    put32 40 to f
    put32  x to f
    put32  y to f
    put16  1 to f
    put16 24 to f
    6.times { put32 0 to f; }
    // Image.
    write data rgb_dir (-1) v_dir (-1) size (x,y) type comp with_alpha 0 pad pad in f
    FILE_UTILS.close f
    TRUE
  )
  
Private
  
  - high_bit pz:UINTEGER_32 :INTEGER <-
  // returns 0..31 for the highest set bit
  ( + n:INTEGER
    + z:UINTEGER_32
    z := pz
    (z = 0).if { n := -1; } else {
      (z >= 10000h).if { n := n + 16; z := z >> 16; }
      (z >= 00100h).if { n := n +  8; z := z >>  8; }
      (z >= 00010h).if { n := n +  4; z := z >>  4; }
      (z >= 00004h).if { n := n +  2; z := z >>  2; }
      (z >= 00002h).if { n := n +  1; z := z >>  1; }
    }
    n
  )

  - bitcount pa:UINTEGER_32 :INTEGER <- // BSBS: A voir avec la lib...
  ( + a:UINTEGER_32
    a := pa
    a := (a & 55555555h) + ((a >>  1) & 55555555h); // max 2
    a := (a & 33333333h) + ((a >>  2) & 33333333h); // max 4
    a := (a + (a >> 4)) & 0f0f0f0fh; // max 8 per 4, now 8 bits
    a := (a + (a >> 8));  // max 16 per 8 bits
    a := (a + (a >> 16)); // max 32 per 8 bits
    (a & 0ffh).to_integer
  )

  - shiftsigned v:INTEGER shift shift:INTEGER bits bits:INTEGER :UINTEGER_8 <-
  ( + result,z,vv:UINTEGER_8
    (shift < 0).if { vv := v << -shift; } else { vv := v >> shift; }
    result := vv
    z := bits
    {z < 8}.while_do {
      result := result + vv >> z
      z := z + bits
    }
    result
  )

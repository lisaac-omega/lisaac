Header  
  + name := IMG_PNG;
  /*
    public domain 'baseline' PNG decoder  
      simple implementation
       - only 8-bit samples
       - no CRC checking
       - allocates lots of intermediate memory
       - avoids problem of streaming data between subsystems
       - avoids explicit window management
       performance
       - uses zlib, a PD zlib implementation with fast huffman decoding
  */
  - external := `
  int xorig[] = { 0,4,0,2,0,1,0 };
  int yorig[] = { 0,0,4,0,2,0,1 };
  int xspc[]  = { 8,8,4,4,2,2,1 };
  int yspc[]  = { 8,8,8,4,4,2,2 };
  `;
  
Inherit  
  - parent_image:IMAGE := IMAGE
  
Public
  
  - xorig i:INTEGER :INTEGER <- `xorig[@i]`:INTEGER
  - yorig i:INTEGER :INTEGER <- `yorig[@i]`:INTEGER
  - xspc  i:INTEGER :INTEGER <- `xspc[@i]`:INTEGER
  - yspc  i:INTEGER :INTEGER <- `yspc[@i]`:INTEGER
      
  - f_none:UINTEGER_8 := 0
  - f_sub:UINTEGER_8  := 1
  - f_up:UINTEGER_8   := 2
  - f_avg:UINTEGER_8  := 3
  - f_paeth:UINTEGER_8:= 4
  // synthetic filters used for first scanline to avoid needing a dummy row of 0s
  - f_avg_first:UINTEGER_8   := 5
  - f_paeth_first:UINTEGER_8 := 6
  
  + idata:NATIVE_ARRAY UINTEGER_8
  + expanded:NATIVE_ARRAY UINTEGER_8
  + out:NATIVE_ARRAY UINTEGER_8
  
  - get_chunk_header:PNGCHUNK <- PNGCHUNK.create_length get32be type get32be

  - check_png_header:BOOLEAN <-
  (
    rewind
    (get8=89h) && {get8=50h} && {get8=4Eh} && {get8=47h} && 
    {get8=0Dh} && {get8=0Ah} && {get8=1Ah} && {get8=0Ah}
  )

  - first_row_filter:NATIVE_ARRAY UINTEGER_8 := 
  ( + r:NATIVE_ARRAY UINTEGER_8
    r := NATIVE_ARRAY UINTEGER_8.create 5
    r.at 0 put f_none
    r.at 1 put f_sub
    r.at 2 put f_none
    r.at 3 put f_avg_first
    r.at 4 put f_paeth_first
    r
  )

  - paeth (a,b,c:INTEGER) :INTEGER <-
  ( + p,pa,pb,pc,res:INTEGER
    //"abc:".print; a.print; ','.print; b.print; ','.print; c.println
    p  := a + b - c
    pa := (p-a).abs
    pb := (p-b).abs
    pc := (p-c).abs
    ((pa <= pb) && {pa <= pc}).if {
      res := a
    }.elseif {pb <= pc} then {
      res := b
    } else {
      res := c
    }
    res
  )

  - depth_scale_table:NATIVE_ARRAY UINTEGER_8 := 
  ( + res:NATIVE_ARRAY UINTEGER_8
    res := NATIVE_ARRAY UINTEGER_8.create 9
    res.at 1 put 0FFh; res.at 2 put 055h
    res.at 4 put 011h; res.at 8 put 001h
    res
  )

  // create the png data from post-deflated data
  - create_png_image_raw (praw:NATIVE_ARRAY UINTEGER_8, raw_len:UINTEGER_32 , out_n:INTEGER)
  to (x,y:UINTEGER_32) depth depth:INTEGER color color:INTEGER <-
  ( + stride:UINTEGER_32
    + img_len, img_width_bytes:UINTEGER_32
    + k,limg_n:INTEGER
    + raw,bug:NATIVE_ARRAY UINTEGER_8
    limg_n := img_n; // copy it into a local for later
    stride := x * out_n
    raw := praw
    out := NATIVE_ARRAY UINTEGER_8.create (x * y * out_n); // extra bytes to write off the end into
    
    img_width_bytes := (((img_n * x * depth) + 7) >> 3)
    img_len := (img_width_bytes + 1) * y
    ((img_x = x) && {img_y = y}).if {
      (raw_len != img_len).if { return_error "not enough pixels"; }
    } else { // interlaced:
      (raw_len < img_len).if { return_error "not enough pixels"; }
    }
    bug := raw
    0.to (y-1) do { j:INTEGER
      + cur,prior:NATIVE_ARRAY UINTEGER_8
      + filter,filter_bytes,width:INTEGER
      cur := out + stride*j
      //"---- ".print; (raw #- bug).println
      prior := cur - stride
      filter := raw.first
      raw := raw + 1
      filter_bytes := img_n
      width := x
      //"filter:".print; filter.println
      (filter > 4).if {
        return_error "invalid filter"
      }
      (depth < 8).if {
        ? {img_width_bytes <= x}
        cur := cur + (x*out_n - img_width_bytes); // store output to the rightmost img_len bytes, so we can decode in place
        filter_bytes := 1
        width := img_width_bytes
      }
      //"--A-- ".print; (raw #- bug).println
      // if first row, use special filter that doesn't sample previous row
      (j = 0).if { filter := first_row_filter.at filter; }
      // handle first byte explicitly
      0.to (filter_bytes-1) do { k:INTEGER
        (filter)
        .when f_none        then { cur.at k put (raw.at k); }
        .when f_sub         then { cur.at k put (raw.at k); }
        .when f_up          then { cur.at k put (bytecast(raw.at k + prior.at k)); }
        .when f_avg         then { cur.at k put (bytecast(raw.at k.to_integer + prior.at k >>1)); }
        .when f_paeth       then { cur.at k put (bytecast(raw.at k + paeth(0,prior.at k,0))); }
        .when f_avg_first   then { cur.at k put (raw.at k); }
        .when f_paeth_first then { cur.at k put (raw.at k); }
      }
      (depth = 8).if {
        (img_n != out_n).if {
          cur.at img_n put 255; // first pixel
        }
        raw := raw + img_n
        cur := cur + out_n
        prior := prior + out_n
      } else {
        raw := raw + 1
        cur := cur + 1
        prior := prior + 1
      }
      //"--B-- ".print; (raw #- bug).println
      // this is a little gross, so that we don't switch per-pixel or per-component
      ((depth < 8) || {img_n = out_n}).if {
        + nk:INTEGER
        + c:{(INTEGER,INTEGER,{INTEGER;}); }
        nk := (width - 1)*img_n
        c := {(f,v:INTEGER,b:{INTEGER;}); (f=v).if { 0.to (nk-1) do b; }; }
        (filter = f_none).if { memcpy(cur, raw, nk); }
        c.value (filter,f_sub,{k:INTEGER
            cur.at k put (bytecast(raw.at k + cur.at (k-filter_bytes)))
        })
        c.value (filter,f_up ,{k:INTEGER
            cur.at k put (bytecast(raw.at k + prior.at k))
        })
        c.value (filter,f_avg,{k:INTEGER
            cur.at k put (bytecast(raw.at k + ((prior.at k.to_integer + cur.at (k-filter_bytes))>>1)))
        })
        c.value (filter,f_paeth,{k:INTEGER
            cur.at k put (bytecast(raw.at k + paeth(cur.at (k-filter_bytes),prior.at k,prior.at (k-filter_bytes))))
        })
        c.value (filter,f_avg_first,{k:INTEGER
            cur.at k put (bytecast(raw.at k + (cur.at (k-filter_bytes) >> 1)))
        })
        c.value (filter,f_paeth_first,{k:INTEGER
            cur.at k put (bytecast(raw.at k + paeth(cur.at (k-filter_bytes),0,0)))
        })
        raw := raw + nk
        //"--B1-- ".print; (raw #- bug).println
      } else {
        + c:{(INTEGER,INTEGER,{INTEGER;}); }
        //"--B2-- ".print; (raw #- bug).println
        ? {img_n+1 = out_n}
        c := {(f,v:INTEGER,b:{INTEGER;}); (f=v).if {
            //"x-1:".print; (x-1).println
            (x-1).to_integer.downto 1 do { i:INTEGER
              0.to (img_n-1) do b
              //"i:".print; i.println
              cur.at img_n put 255
              raw := raw + img_n
              cur := cur + out_n
              prior := prior + out_n
            }
        }; }
        //"filter:".print; filter.print; " f_sub:".print; f_sub.print; " out_n:".print; out_n.println
        c.value (filter,f_none,{k:INTEGER
            cur.at k put (raw.at k)
        })
        c.value (filter,f_sub,{k:INTEGER
            //+ col:UINTEGER_8
            //    (k-out_n).println
            cur.at k put (bytecast(raw.at k + cur.at (k-out_n)))
            //"f_sub:".print; cur.at k.println
        })
        c.value (filter,f_up,{k:INTEGER
            cur.at k put (bytecast(raw.at k + prior.at k))
            //"f_up:".print; cur.at k.println
        })
        c.value (filter,f_avg,{k:INTEGER
            cur.at k put (bytecast(raw.at k + ((prior.at k.to_integer + cur.at (k-out_n))>>1)))
            //"f_avg:".print; cur.at k.println
        })
        c.value (filter,f_paeth,{k:INTEGER
            + cc:UINTEGER_8
            cc := (bytecast(raw.at k + paeth(cur.at (k-out_n),prior.at k,prior.at (k-out_n))))
            //cc.println
            cur.at k put cc
        })
        c.value (filter,f_avg_first,{k:INTEGER
            cur.at k put (bytecast(raw.at k + (cur.at (k-out_n) >> 1)))
            //"f_avg_first:".print; cur.at k.println
        })
        c.value (filter,f_paeth_first,{k:INTEGER
            cur.at k put (bytecast(raw.at k + paeth(cur.at (k-out_n),0,0)))
            //"f_peath_first:".print; cur.at k.println
        })
      }
    }
    //"--C-- ".print; (raw #- bug).println
    //"step 1\n".print
    //0.to (x * y * out_n-1) do { i:INTEGER
    //  out.at i.println
    //}
    
    // we make a separate pass to expand bits to pixels; for performance,
    // this could run two scanlines behind the above code, so it won't
    // intefere with filtering but will still be in the cache.
    (depth < 8).if {
      0.to (y-1) do { j:INTEGER
        + cur,in:NATIVE_ARRAY UINTEGER_8
        + scale:UINTEGER_8
        cur := out + stride*j
        in  := out + stride*j + x*out_n - img_width_bytes
        // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
        // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
        scale := (color = 0).ok (depth_scale_table.at depth) or 1; // scale grayscale values to 0..255 range

        // note that the final byte might overshoot and write more data than desired.
        // we can allocate enough data that this never writes out of memory, but it
        // could also overwrite the next scanline. can it overwrite non-empty data
        // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
        // so we need to explicitly clamp the final ones

        (depth = 4).if {
          (x*img_n).downto 2 by 2 do { k:UINTEGER_32
            cur.at 0 put (scale * (in.first >>  4))
            cur.at 1 put (scale * (in.first & 0Fh))
            cur := cur + 2
            in := in + 1
          }
          (k > 0).if { 
            cur.at 0 put (scale * ((in.first >> 4)))
            cur := cur + 1
          }
        }.elseif {depth = 2} then {          
          (x*img_n).downto 4 by 4 do { k:UINTEGER_32
            cur.at 0 put (scale *  (in.first >> 6))
            cur.at 1 put (scale * ((in.first >> 4)&03h))
            cur.at 2 put (scale * ((in.first >> 2)&03h))
            cur.at 3 put (scale * ((in.first     )&03h))
            cur := cur + 4
            in := in + 1
          }
          (k > 0).if {
            cur.at 0 put (scale * (in.first >> 6)); cur := cur + 1
          }
          (k > 1).if { 
            cur.at 0 put (scale * ((in.first >> 4)&03h)); cur := cur + 1
          }
          (k > 2).if {
            cur.at 0 put (scale * ((in.first >> 2)&03h)); cur := cur + 1
          }
        }.elseif {depth = 1} then {
          (x*img_n).downto 8 by 8 do { k:UINTEGER_32
            cur.at 0 put (scale * ((in.first >> 7)      ))
            cur.at 1 put (scale * ((in.first >> 6) & 01h))
            cur.at 2 put (scale * ((in.first >> 5) & 01h))
            cur.at 3 put (scale * ((in.first >> 4) & 01h))
            cur.at 4 put (scale * ((in.first >> 3) & 01h))
            cur.at 5 put (scale * ((in.first >> 2) & 01h))
            cur.at 6 put (scale * ((in.first >> 1) & 01h))
            cur.at 7 put (scale * ((in.first     ) & 01h))
            cur := cur + 8
            in := in + 1
          }
          (k > 0).if {
            cur.at 0 put (scale * (in.first >> 7)); cur := cur + 1
          }
          (k > 1).if {
            cur.at 0 put (scale * ((in.first >> 6)&01h)); cur := cur + 1
          }
          (k > 2).if {
            cur.at 0 put (scale * ((in.first >> 5)&01h)); cur := cur + 1
          }
          (k > 3).if {
            cur.at 0 put (scale * ((in.first >> 4)&01h)); cur := cur + 1
          }
          (k > 4).if {
            cur.at 0 put (scale * ((in.first >> 3)&01h)); cur := cur + 1
          }
          (k > 5).if {
            cur.at 0 put (scale * ((in.first >> 2)&01h)); cur := cur + 1
          }
          (k > 6).if {
            cur.at 0 put (scale * ((in.first >> 1)&01h)); cur := cur + 1
          }
        }
        (img_n != out_n).if {          
          // insert alpha = 255
          cur := out + stride*j
          (img_n = 1).if {
            (x-1).downto 0 do { q:UINTEGER_32
              cur.at (q*2+1) put 255
              cur.at (q*2+0) put (cur.at q)
            }
          } else {
            ? {img_n = 3}
            (x-1).downto 0 do { q:UINTEGER_32
              cur.at (q*4+3) put 255
              cur.at (q*4+2) put (cur.at (q*3+2))
              cur.at (q*4+1) put (cur.at (q*3+1))
              cur.at (q*4+0) put (cur.at (q*3+0))
            }
          }
        }
      }
    }
    //"step 2\n".print
    //0.to (x*y*img_n-1) do { i:INTEGER
    //  out.at i.println
    //}
    
  )

  - create_png_image (pimage_data:NATIVE_ARRAY UINTEGER_8, pimage_data_len:UINTEGER_32,out_n,depth,color:INTEGER,interlaced:BOOLEAN) <-
  ( + final,image_data:NATIVE_ARRAY UINTEGER_8
    + out_x,out_y:INTEGER
    + image_data_len:UINTEGER_32
    image_data := pimage_data
    image_data_len := pimage_data_len
    (!interlaced).if {
      //"no interlaced\n".print
      create_png_image_raw(image_data, image_data_len, out_n) to (img_x, img_y) depth depth color color
    } else {
      // de-interlacing
      //"interlaced!\n".print
      final := NATIVE_ARRAY UINTEGER_8.create (img_x * img_y * out_n)
      0.to 6 do { p:INTEGER
        + x,y:INTEGER
        // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
        x := (img_x - xorig p + xspc p -1) / xspc p
        y := (img_y - yorig p + yspc p -1) / yspc p
        //x.print; ','.print; y.println
        ((x != 0) && {y != 0}).if {
          + img_len:UINTEGER_32
          img_len := ((((img_n * x * depth) + 7) >> 3) + 1) * y
          create_png_image_raw (image_data, image_data_len, out_n) to (x, y) depth depth color color
          0.to (y-1) do { j:INTEGER
            0.to (x-1) do { i:INTEGER
              out_y := j * yspc p + yorig p
              out_x := i * xspc p + xorig p
              memcpy(final + out_y*img_x*out_n + out_x*out_n,out + (j*x+i)*out_n, out_n)
            }
          }
          // STBI_FREE(a->out)
          image_data := image_data + img_len
          image_data_len := image_data_len - img_len
        }
      }
      out := final
    }
  )

  - compute_transparency (tc:NATIVE_ARRAY UINTEGER_8, out_n:INTEGER) <-
  ( + pixel_count:UINTEGER_32
    + p:NATIVE_ARRAY UINTEGER_8
    pixel_count := img_x * img_y
    p := out

    // compute color-based transparency, assuming we've
    // already got 255 as the alpha value in the output
    ? {(out_n = 2) || {out_n = 4}}

    (out_n = 2).if {
      0.to (pixel_count-1) do { i:INTEGER
        p.at 1 put ((p.at 0 = tc.at 0).ok 0 or 255)
        p := p + 2
      }
    } else {
      0.to (pixel_count-1) do { i:INTEGER
        ((p.at 0 = tc.at 0) && {p.at 1 = tc.at 1} && {p.at 2 = tc.at 2}).if {
          p.at 3 put 0
        }
        p := p + 4
      }
    }
  )

  - expand_png_palette (palette:NATIVE_ARRAY UINTEGER_8, pal_img_n:INTEGER) <-
  ( + pixel_count:UINTEGER_32
    + p, temp_out, orig:NATIVE_ARRAY UINTEGER_8
    + n:UINTEGER_8
    
    pixel_count := img_x * img_y
    orig := out
    p := NATIVE_ARRAY UINTEGER_8.create (pixel_count * pal_img_n)
    // between here and free(out) below, exitting would leak
    temp_out := p

    (pal_img_n = 3).if {
      0.to (pixel_count-1) do { i:INTEGER
        n := orig.at i*4
        p.at 0 put (palette.at  n   )
        p.at 1 put (palette.at (n+1))
        p.at 2 put (palette.at (n+2))
        p := p + 3
      }
    } else {
      0.to (pixel_count-1) do { i:INTEGER
        n := orig.at i*4
        p.at 0 put (palette.at  n   )
        p.at 1 put (palette.at (n+1))
        p.at 2 put (palette.at (n+2))
        p.at 3 put (palette.at (n+3))
        p := p + 4
      }
    }
    //STBI_FREE(a->out)
    out := temp_out
  )

  - unpremultiply_on_load:BOOLEAN
  - de_iphone_flag:BOOLEAN

  - set_unpremultiply_on_load flag:BOOLEAN <-
  ( unpremultiply_on_load := flag; )

  - convert_iphone_png_to_rgb flag:BOOLEAN <-
  ( de_iphone_flag := flag; )
  
  - de_iphone <-
  ( + i, pixel_count:UINTEGER_32
    + p:NATIVE_ARRAY UINTEGER_8
    + t,a:UINTEGER_8
    p := out
    pixel_count := img_x * img_y
    
    (img_out_n = 3).if {  // convert bgr to rgb
      0.to (pixel_count-1) do { i:INTEGER
        t := p.at 0
        p.at 0 put (p.at 2)
        p.at 2 put t
        p := p + 3
      }
    } else {
      ? {img_out_n = 4}
      (unpremultiply_on_load).if {
        // convert bgr to rgb and unpremultiply
        0.to (pixel_count-1) do { i:INTEGER
          a := p.at 3
          t := p.at 0
          (a != 0).if {
            p.at 0 put (p.at 2 * 255 / a)
            p.at 1 put (p.at 1 * 255 / a)
            p.at 2 put (t        * 255 / a)
          } else {
            p.at 0 put (p.at 2)
            p.at 2 put t
          }
          p := p + 4
        }
      } else {
        // convert bgr to rgb
        0.to (pixel_count-1) do { i:INTEGER
          t := p.at 0
          p.at 0 put (p.at 2)
          p.at 2 put t
          p := p + 4
        }
      }
    }
  )

  - id (a,b,c,d:CHARACTER):UINTEGER_32 <- 
  (
    (a.to_integer.to_uinteger_32 << 24) + (b.to_integer.to_uinteger_32 << 16) + 
    (c.to_integer.to_uinteger_32 <<  8) +  d.to_integer.to_uinteger_32
  )

  - parse_png_file (pscan,req_comp:INTEGER) <-
  ( + palette,tc:NATIVE_ARRAY UINTEGER_8
    + pal_img_n:UINTEGER_8
    + has_trans:BOOLEAN
    + ioff, idata_limit, pal_len:UINTEGER_32
    + color, depth,scan:INTEGER
    + interlace, first,stop, is_iphone:BOOLEAN
    
    palette := NATIVE_ARRAY UINTEGER_8.create 1024; // BSBS: Merdic !!!
    tc := NATIVE_ARRAY UINTEGER_8.create 3; // BSBS: GIGA Merdic !!!!!!
    
    scan := `@pscan`:INTEGER; // BSBS: Bug Compilo 2019
    
    first := TRUE
    expanded := NULL
    idata := NULL
    out := NULL

    (! check_png_header).if { return_error "Check header"; }

    (scan != scan_type).if { 
      {! stop}.while_do {
        + c:PNGCHUNK
        c := get_chunk_header
        (c.type = id('C','g','B','I')).if {
          //"CgBI\n".print
          is_iphone := TRUE
          skip (c.length)
        }.elseif {c.type = id('I','H','D','R')} then {
          + comp,filter:INTEGER
          //"IHDR\n".print
          (! first).if { return_error "multiple IHDR"; }
          first := FALSE
          (c.length != 13).if { return_error "bad IHDR len"; }
          img_x := get32be; (img_x > (1 << 24)).if { return_error "too large"; }
          img_y := get32be; (img_y > (1 << 24)).if { return_error "too large"; }
          depth := get8;   ((depth != 1) && {depth != 2} && {depth != 4} && {depth != 8}).if { return_error "1/2/4/8-bit only"; }
          color := get8;   (color > 6).if { return_error "bad ctype"; }
          (color = 3).if { pal_img_n := 3; }.elseif {(color & 1) != 0} then { return_error "bad ctype"; }
          comp  := get8;  (comp   != 0).if { return_error "bad comp method"; }
          filter:= get8;  (filter != 0).if { return_error "bad filter method"; }
          interlace := get8=1
          ? {(img_x != 0) && {img_y != 0}}
          (pal_img_n = 0).if {
            img_n := (((color & 2) != 0).ok 3 or 1) + (((color & 4) != 0).ok 1 or 0)
            ((1 << 30) / img_x / img_n < img_y).if { return_error "too large"; }
            (scan = scan_header).if { stop := TRUE; }
          } else {
            // if paletted, then pal_n is our final components, and
            // img_n is # components to decompress/filter.
            img_n := 1
            ((1 << 30) / img_x / 4 < img_y).if { return_error "too large"; }
            // if SCAN_header, have to scan to see if we have a tRNS
          }
        }.elseif {c.type = id('P','L','T','E')} then {
          //"PLTE\n".print
          (first).if { return_error "first not IHDR"; }
          (c.length > 256*3).if { return_error "invalid PLTE"; }
          pal_len := c.length / 3
          (pal_len * 3 != c.length).if { return_error "invalid PLTE"; }
          0.to (pal_len-1) do { i:INTEGER
            palette.at (i*4+0) put get8
            palette.at (i*4+1) put get8
            palette.at (i*4+2) put get8
            palette.at (i*4+3) put  255
          }
        }.elseif {c.type = id('t','R','N','S')} then {
          //"tRNS\n".print
          (first).if { return_error "first not IHDR"; }
          (idata != NULL).if { return_error "tRNS after IDAT"; }
          (pal_img_n != 0).if {            
            (scan = scan_header).if { img_n := 4; stop := TRUE; } else {
              (pal_len = 0).if { return_error "tRNS before PLTE"; }
              (c.length > pal_len).if { return_error "bad tRNS len"; }
              pal_img_n := 4
              0.to (c.length-1) do { i:INTEGER
                palette.at (i*4+3) put get8
              }
            }
          } else {
            ((img_n & 1) = 0).if { return_error "tRNS with alpha"; }
            (c.length != img_n*2).if { return_error "bad tRNS len"; }
            has_trans := TRUE
            0.to (img_n-1) do { k:INTEGER
              tc.at k put (((get16be & 255) * depth_scale_table.at depth).to_uinteger_8); // non 8-bit images will be larger
            }
          }
        }.elseif {c.type = id('I','D','A','T')} then {
          //"IDAT\n".print
          (first).if { return_error "first not IHDR"; }
          ((pal_img_n != 0) && {pal_len = 0}).if { return_error "no PLTE"; }
          (scan = scan_header).if { img_n := pal_img_n; stop := TRUE; } else {
            ((ioff + c.length) < ioff).if { return_error "Chepa"; }
            (ioff + c.length > idata_limit).if {
              + idata_limit_old:UINTEGER_32
              + p:NATIVE_ARRAY UINTEGER_8
              idata_limit_old := idata_limit
              (idata_limit = 0).if { idata_limit := (c.length > 4096).ok (c.length) or 4096; }
              {ioff + c.length > idata_limit}.while_do {
                idata_limit := idata_limit * 2
              }
              (idata_limit_old = 0).if {
                p := NATIVE_ARRAY UINTEGER_8.create idata_limit
              } else {
                p := idata.realloc idata_limit_old with idata_limit
              }
              idata := p
            }
            (!getn (idata+ioff) size (c.length)).if { return_error "outofdata"; }
            ioff := ioff + c.length
          }
        }.elseif {c.type = id('I','E','N','D')} then {
          + raw_len, bpl:UINTEGER_32
          //"IEND\n".print
          (first).if { return_error "first not IHDR"; }
          (scan = scan_load).if { 
            (idata = NULL).if { return_error "no IDAT"; }
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl := (img_x * depth + 7) / 8; // bytes per line, per component
            raw_len := bpl * img_y * img_n /* pixels */ + img_y /* filter mode per row */
            //crash; // *****************************
            //stop := TRUE; // ********** BIDON loop without end.
            (expanded, raw_len) := IMG_ZLIB.decode_malloc_guesssize_headerflag (idata, ioff, raw_len) header (!is_iphone)
            //STBI_FREE(z->idata)
            idata := NULL
            (((req_comp = img_n+1) && {req_comp != 3} && {pal_img_n = 0}) || {has_trans}).if {
              //"Ajout 1\n".print
              img_out_n := img_n+1
            } else {
              //"Ajout 0\n".print
              img_out_n := img_n
            }
            create_png_image(expanded, raw_len, img_out_n, depth, color, interlace)
            (has_trans).if {
              compute_transparency(tc, img_out_n)
            }
            (is_iphone && {de_iphone_flag} && {img_out_n > 2}).if {
              de_iphone
            }
            (pal_img_n != 0).if {
              // pal_img_n == 3 or 4
              img_n := pal_img_n; // record the actual colors we had
              img_out_n := pal_img_n
              (req_comp >= 3).if { img_out_n := req_comp; }
              expand_png_palette(palette, pal_len /*, s->img_out_n*/)
            }
            //STBI_FREE(z->expanded)
            expanded := NULL
          }
          stop := TRUE
        } else {
          // if critical, fail
          (first).if { return_error "first not IHDR"; }
          ((c.type & (1 << 29)) = 0).if {
            (c.type&0FFh).print
            ((c.type>>8)&0FFh).print
            ((c.type>>16)&0FFh).print
            ((c.type>>24)&0FFh).print
            '\n'.print
            return_error "PNG not supported: unknown PNG chunk type"
          }
          skip (c.length)
        }
        // end of PNG chunk, read and skip CRC
        get32be
      }
    }
  )

  - load req_comp:INTEGER :NATIVE_ARRAY UINTEGER_8 <-
  ( + result:NATIVE_ARRAY UINTEGER_8
    
    parse_png_file (scan_load, req_comp)
    result := out
    out := NULL
    ((req_comp != 0) && {req_comp != img_out_n}).if {
      //"Convert\n".print
      //req_comp.print; '/'.print; img_n.println
      result := convert_format result from img_out_n to req_comp
    }
    // STBI_FREE(out);      out      := NULL
    // STBI_FREE(expanded); expanded := NULL
    // STBI_FREE(idata);    idata    := NULL
    result
  )

  - test:BOOLEAN <-
  (
    rewind
    check_png_header    
  )

  - info:BOOLEAN <-
  (
    rewind
    parse_png_file (scan_header, 0)
    TRUE
  )
  
  

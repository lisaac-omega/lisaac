Header
  
  + name := FONTINFO;

Inherit
  
  - parent_ttf_constant:TTF_CONSTANT := TTF_CONSTANT

Public

  + userdata:NATIVE_ARRAY UINTEGER_8
  - set_userdata d:NATIVE_ARRAY UINTEGER_8 <- ( userdata := d; )
  
  + data:NATIVE_ARRAY UINTEGER_8; // pointer to .ttf file
  + fontstart:INTEGER;            // offset of start of font

  + num_glyphs:INTEGER; // number of glyphs, needed for range checking
  
  // table locations as offset from start of .ttf
  + loca:INTEGER
  + head:INTEGER
  + glyf:INTEGER
  + hhea:INTEGER
  + hmtx:INTEGER
  + kern:INTEGER
  
  // a cmap mapping for our chosen character encoding
  + index_map:INTEGER
  
  // format needed to map from glyph index to glyph
  + index_to_loc_format:INTEGER
  
  - create_font dta:NATIVE_ARRAY UINTEGER_8 start ftstart:INTEGER :SELF <-
  ( + result:SELF
    result := clone
    result.init_font dta start ftstart
    result
  )
  
  - init_font dta:NATIVE_ARRAY UINTEGER_8 start ftstart:INTEGER <-
  ( + cmap,t,encoding_record:UINTEGER_32
    + num_tables:INTEGER_32
    + n:UINTEGER_16

    data := dta
    fontstart := ftstart

    cmap := find_table (dta, ftstart) name "cmap"
    loca := find_table (dta, ftstart) name "loca"
    head := find_table (dta, ftstart) name "head"
    glyf := find_table (dta, ftstart) name "glyf"
    hhea := find_table (dta, ftstart) name "hhea"
    hmtx := find_table (dta, ftstart) name "hmtx"
    kern := find_table (dta, ftstart) name "kern"; // not required
    (
      (cmap!=0) && {loca!=0} && {head!=0} && {glyf!=0} && {hhea!=0} && {hmtx!=0}
    ).if {
      t := find_table (dta, ftstart) name "maxp"
      (t!=0).if {
        num_glyphs := ttushort(dta+t+4)
      } else {
        num_glyphs := 0FFFFh
      }
      // find a cmap encoding table we understand *now* to avoid searching
      // later. (todo: could make this installable)
      // the same regardless of glyph.
      num_tables := ttushort(dta + cmap + 2)
      index_map := 0
      0.to (num_tables-1) do { i:INTEGER
        encoding_record := cmap + 4 + 8 * i
        // find an encoding we understand:
        n := ttushort(dta+encoding_record)
        (n = platform_id_microsoft).if {
          n := ttushort(dta+encoding_record+2)
          ((n = ms_eid_unicode_bmp) || {n = ms_eid_unicode_full}).if {
            // MS/Unicode
            `/* Pb avec le compilo 0.42 en -boost */`
            index_map := cmap + ttulong(dta+encoding_record+4)
          }
        }.elseif {n = platform_id_unicode} then {
          // Mac/iOS has these
          // all the encodingIDs are unicode, so we don't bother to check it
          index_map := cmap + ttulong(dta+encoding_record+4)
        }
      }
      (index_map != 0).if {
        index_to_loc_format := ttushort(dta+head + 50)
      }
    }
  )
    
  - find_glyph_index unicode_pt:UINTEGER_32 :INTEGER <-
  ( + dta:NATIVE_ARRAY UINTEGER_8
    + idx:UINTEGER_32
    + format:UINTEGER_16
    + result:INTEGER
    
    dta := data
    idx := index_map
    format := ttushort(dta + idx + 0)
    (format = 0).if { // apple byte encoding
      + bytes:UINTEGER_32
      bytes := ttushort(dta + idx + 2)
      (unicode_pt < bytes-6).if {
        result := ttbyte(dta + idx + 6 + unicode_pt)
      }
    }.elseif {format = 6} then {
      + first,count:UINTEGER_32
      first := ttushort(dta + idx + 6)
      count := ttushort(dta + idx + 8)
      ((unicode_pt >= first) && {unicode_pt < first+count}).if {
        result := ttushort(dta + idx + 10 + (unicode_pt - first)*2)
      }
    }.elseif {format = 2} then {
      // @TODO: high-byte mapping for japanese/chinese/korean
      not_yet_implemented
    }.elseif {format = 4} then { 
      // standard mapping for windows fonts: binary 
      // search collection of ranges
      + segcount,search_range,entry_selector,range_shift:UINTEGER_16
      + end_count,search:UINTEGER_32
      + offset,start,item:UINTEGER_16
      segcount := ttushort(dta+idx+6) >> 1
      search_range := ttushort(dta+idx+8) >> 1
      entry_selector := ttushort(dta+idx+10)
      range_shift := ttushort(dta+idx+12) >> 1
      // do a binary search of the segments
      end_count := idx + 14
      search := end_count
      (unicode_pt <= 0FFFFh).if {
        // they lie from endCount .. endCount + segCount
        // but searchRange is the nearest power of two, so...
        (unicode_pt >= ttushort(dta + search + range_shift*2)).if {
          search := search + range_shift*2
        }
        // now decrement to bias correctly to find smallest
        search := search - 2
        {entry_selector!=0}.while_do {
          + end:UINTEGER_16
          search_range := search_range >> 1
          end := ttushort(dta + search + search_range*2)
          (unicode_pt > end).if {
            search := search + search_range*2
          }
          entry_selector := entry_selector - 1
        }
        search := search + 2
        item := ((search - end_count) >> 1).to_uinteger_16
        
        ? {unicode_pt <= ttushort(dta + end_count + 2*item)}
        start := ttushort(dta + idx + 14 + segcount*2 + 2 + 2*item)
        (unicode_pt >= start).if {
          offset := ttushort(dta + idx + 14 + segcount*6 + 2 + 2*item)
          (offset = 0).if {
            result := unicode_pt.to_integer + ttshort(dta + (idx + 14 + segcount*4 + 2 + 2*item))
          } else {
            result := ttushort(dta + offset + (unicode_pt-start)*2 + idx + 14 + segcount*6 + 2 + 2*item)
          }
        }
      }
    }.elseif {(format = 12) || {format = 13}} then {
      + ngroups:INTEGER_32
      + low,high:INTEGER_32
      ngroups := ttlong(dta+idx+12)
      low := 0; high := ngroups
      // Binary search the right group.
      {(low < high) && {result = 0}}.while_do {
        + mid:INTEGER_32
        + start_char,end_char:UINTEGER_32
        mid := low + ((high-low) >> 1); // rounds down, so low <= mid < high
        start_char := ttulong(dta+idx+16+mid*12)
        end_char := ttulong(dta+idx+16+mid*12+4)
        (unicode_pt < start_char).if {
          high := mid
        }.elseif {unicode_pt > end_char} then {
          low := mid+1
        } else {
          + start_glyph:UINTEGER_32
          start_glyph := ttulong(dta+idx+16+mid*12+8)
          (format = 12).if {
            result := start_glyph + unicode_pt-start_char
          } else { // format == 13
            result := start_glyph
          }
        }
      }
    } else {
      // @TODO
      not_yet_implemented
    }
    result
  )
    
  - get_codepoint_shape unicode_pt:INTEGER in vertices:ARRAY TT_VERTEX :INTEGER <-
  (
    get_glyph_shape (find_glyph_index unicode_pt) in vertices
  )
  
  - get_glyf_offset glyph_index:INTEGER :INTEGER <-
  ( + g1,g2:INTEGER
    + result:INTEGER

    ((glyph_index >= num_glyphs) || {index_to_loc_format >= 2}).if {
      result := -1; // unknown index->glyph map format
    } else {
      (index_to_loc_format = 0).if {
        g1 := glyf + ttushort(data + loca + glyph_index * 2) * 2
        g2 := glyf + ttushort(data + loca + glyph_index * 2 + 2) * 2
      } else {
        g1 := glyf + ttulong(data + loca + glyph_index * 4)
        g2 := glyf + ttulong(data + loca + glyph_index * 4 + 4)
      }
      result := (g1=g2).ok (-1) or g1; // if length is 0, return -1
    }
    result
  )

  - get_glyph_box glyph_index:INTEGER 
  :(INTEGER,INTEGER,INTEGER,INTEGER) <-
  ( + g,x0,y0,x1,y1:INTEGER
    g := get_glyf_offset glyph_index
    (g >= 0).if {
      x0 := ttshort (data + (g + 2))
      y0 := ttshort (data + (g + 4))
      x1 := ttshort (data + (g + 6))
      y1 := ttshort (data + (g + 8))
    }
    x0,y0, x1,y1
  )

  - get_codepoint_box info:FONTINFO code codepoint:INTEGER 
  :(INTEGER,INTEGER,INTEGER,INTEGER) <-
  (
    get_glyph_box info index (find_glyph_index(info,codepoint))
  )

  - is_glyph_empty glyph_index:INTEGER :BOOLEAN <-
  ( + g:INTEGER
    g := get_glyf_offset glyph_index
    (g < 0) || {ttshort(data + g) = 0}
  )

  - close_shape (vertices:ARRAY TT_VERTEX,num_verts:INTEGER) 
  offset (was_off,start_off:BOOLEAN)
  size (sx,sy,scx,scy,cx,cy:INTEGER_32) :INTEGER <-
  ( + num_vertices:INTEGER
    num_vertices := num_verts
    (start_off).if {
      (was_off).if {
        vertices.at num_vertices.make vcurve pos ((cx+scx)>>1,(cy+scy)>>1,cx,cy)
        num_vertices := num_vertices + 1
      }
      vertices.at num_vertices.make vcurve pos (sx,sy,scx,scy)
      num_vertices := num_vertices + 1
    } else {
      (was_off).if {
        vertices.at num_vertices.make vcurve pos (sx,sy,cx,cy)
        num_vertices := num_vertices + 1
      } else {
        vertices.at num_vertices.make vline pos (sx,sy,0,0)
        num_vertices := num_vertices + 1
      }
    }
    num_vertices
  )

  - get_glyph_shape glyph_index:INTEGER :ARRAY TT_VERTEX <-
  ( + number_of_contours:INTEGER_16
    + dta,end_pts_of_contours:NATIVE_ARRAY UINTEGER_8
    + vertices:ARRAY TT_VERTEX
    + g,num_vertices:INTEGER
    dta := data
    g := get_glyf_offset glyph_index

    (g >= 0).if { 
      number_of_contours := ttshort(dta + g)
      (number_of_contours > 0).if {
        + flags,flagcount:UINTEGER_8
        + ins,i,j,m,n,next_move:INTEGER_32
        + was_off,start_off:BOOLEAN
        + x,y,cx,cy,sx,sy, scx,scy:INTEGER_32
        + points:NATIVE_ARRAY UINTEGER_8
        + off:INTEGER
        end_pts_of_contours := dta + g + 10
        ins := ttushort(dta + g + 10 + number_of_contours * 2)
        points := dta + (g + 10 + number_of_contours * 2 + 2 + ins)
        n := ttushort(end_pts_of_contours + (number_of_contours*2-2))+1
        // a loose bound on how many vertices we might need
        m := n + 2*number_of_contours
        vertices := alloc_vertices m
        next_move := flagcount := 0
        // in first pass, we load uninterpreted data into the allocated array
        // above, shifted to the end of the array so we won't overwrite it when
        // we create our final data starting from the front
        // starting offset for uninterpreted data, regardless 
        // of how m ends up being calculated
        off := m - n
        
        // first load flags        
        0.to (n-1) do { i:INTEGER
          (flagcount = 0).if {
            flags := points.first.to_uinteger_8
            points := points + 1
            ((flags & 8) != 0).if {
              flagcount := points.first.to_uinteger_8
              points := points + 1
            }
          } else {
            flagcount := flagcount - 1
          }
          vertices.at (off+i).set_type flags
        }
        
        // now load x coordinates
        x := 0
        0.to (n-1) do { i:INTEGER
          flags := vertices.at (off+i).type
          ((flags & 2) != 0).if {
            + dx:INTEGER_16
            dx := points.first
            points := points + 1
            x := x + ((flags & 16)!=0).ok dx or (-dx)
          } else {
            ((flags & 16) = 0).if {
              //"x:".print; x.print; ' '.print
              //points.first.print; 'x'.print; points.second.print; '\n'.print
              x := x + (points.first.to_integer_16<<8 | points.second)
              points := points + 2
            }
          }
          //"ofs+i:".print; (off+i).print; " x:".print; x.to_integer_16.print; '\n'.print
          vertices.at (off+i).set_x (x.to_integer_16)
        }

        // now load y coordinates
        y := 0
        0.to (n-1) do { i:INTEGER
          flags := vertices.at (off+i).type
          ((flags & 4) != 0).if {
            + dy:INTEGER_16
            dy := points.first
            points := points + 1
            y := y + ((flags & 32)!=0).ok dy or (-dy)
          } else {
            ((flags & 32) = 0).if {
              y := y + (points.first.to_integer_16<<8 | points.second)
              points := points + 2
            }
          }
          vertices.at (off+i).set_y (y.to_integer_16)
        }

        // now convert them to our format
        sx := sy := cx := cy := scx := scy := 0
        i := 0
        {i < n}.while_do {
          flags := vertices.at (off+i).type
          x     := vertices.at (off+i).x
          y     := vertices.at (off+i).y
          (next_move = i).if {
            (i != 0).if {
              num_vertices := close_shape (vertices,num_vertices)
              offset (was_off, start_off)
              size (sx,sy,scx,scy,cx,cy)
            }
            // now start the new one               
            start_off := (flags & 1) = 0
            (start_off).if {
              // if we start off with an off-curve point, 
              // then when we need to find a point on the curve
              // where we can start, and we need to save some 
              // state for when we wraparound.
              scx := x
              scy := y
              ((vertices.at (off+i+1).type & 1) = 0).if {
                // next point is also a curve point, 
                // so interpolate an on-point curve
                sx := (x + vertices.at (off+i+1).x) >> 1
                sy := (y + vertices.at (off+i+1).y) >> 1
              } else {
                // otherwise just use the next point as our start point
                sx := vertices.at (off+i+1).x
                sy := vertices.at (off+i+1).y
                // we're using point i+1 as the starting point, so skip it
                i := i + 1
              }
            } else {
              sx := x
              sy := y
            }
            vertices.at num_vertices.make vmove pos (sx,sy,0,0)
            num_vertices := num_vertices + 1
            was_off := FALSE
            next_move := 1 + ttushort(end_pts_of_contours+j*2)
            j := j + 1
          } else {
            ((flags & 1) = 0).if { // if it's a curve
              (was_off).if {
                // two off-curve control points in a row 
                // means interpolate an on-curve midpoint
                vertices.at num_vertices.make vcurve pos ((cx+x)>>1,(cy+y)>>1,cx,cy)
                num_vertices := num_vertices + 1
              }
              cx := x
              cy := y
              was_off := TRUE
            } else {
              (was_off).if {
                vertices.at num_vertices.make vcurve pos (x,y,cx,cy)
                num_vertices := num_vertices + 1
              } else {
                vertices.at num_vertices.make vline pos (x,y,0,0)
                num_vertices := num_vertices + 1
              }
              was_off := FALSE
            }
            //"2)num_vertices:".print; num_vertices.print; '\n'.print
          }
          i := i + 1
        }
        //"0)num_vertices:".print; num_vertices.print; '\n'.print
        num_vertices := close_shape (vertices,num_vertices) offset (was_off, start_off) size (sx,sy,scx,scy,cx,cy)
        //"1)num_vertices:".print; num_vertices.print; '\n'.print
        vertices.set_upper (num_vertices-1)
      }.elseif {number_of_contours = -1} then {
        // Compound shapes.
        + more:BOOLEAN
        + comp:NATIVE_ARRAY UINTEGER_8
        comp := dta + g + 10
        more := TRUE
        {more}.while_do {
          + flags, gidx:INTEGER_16
          + t0,m,n:REAL_32
          + comp_verts:ARRAY TT_VERTEX
          + mtx0,mtx1,mtx2,mtx3,mtx4,mtx5:REAL_32
          mtx0 := mtx3 := 1
          
          flags := ttshort comp; comp := comp + 2
          gidx  := ttshort comp; comp := comp + 2
          ((flags & 2) != 0).if { // XY values
            ((flags & 1) != 0).if { // shorts
              mtx4 := ttshort comp.to_real_32; comp := comp + 2
              mtx5 := ttshort comp.to_real_32; comp := comp + 2
            } else {
              mtx4 := ttchar comp.to_real_32; comp := comp + 1
              mtx5 := ttchar comp.to_real_32; comp := comp + 1
            }
          } else {
            // @TODO handle matching point
            not_yet_implemented
          }
          ((flags & (1<<3)) != 0).if { // WE_HAVE_A_SCALE
            t0 := ttshort comp.to_real_32/16384.0
            mtx0 := t0; mtx3 := t0
            comp := comp + 2
            mtx1 := mtx2 := 0
          }.elseif {(flags & (1<<6)) != 0} then { // WE_HAVE_AN_X_AND_YSCALE
            mtx0 := ttshort comp.to_real_32/16384.0; comp := comp + 2
            mtx1 := mtx2 := 0
            mtx3 := ttshort comp.to_real_32/16384.0; comp := comp + 2
          }.elseif {(flags & (1<<7)) != 0} then { // WE_HAVE_A_TWO_BY_TWO
            mtx0 := ttshort comp.to_real_32/16384.0; comp := comp + 2
            mtx1 := ttshort comp.to_real_32/16384.0; comp := comp + 2
            mtx2 := ttshort comp.to_real_32/16384.0; comp := comp + 2
            mtx3 := ttshort comp.to_real_32/16384.0; comp := comp + 2
          }
          // Find transformation scales.
          m := (mtx0*mtx0 + mtx1*mtx1).sqrt
          n := (mtx2*mtx2 + mtx3*mtx3).sqrt
          // Get indexed glyph.
          comp_verts := get_glyph_shape gidx
          //"comp_verts:".print; comp_verts.count.print; '\n'.print
          (comp_verts.count > 0).if {
            // Transform vertices.
            0.to (comp_verts.upper) do { i:INTEGER
              + v:TT_VERTEX
              + x,y:REAL_32
              v := comp_verts.at i
              (x,y) := (v.x.to_real_32,v.y.to_real_32)
              v.set_x ((m * (mtx0*x + mtx2*y + mtx4)).to_integer_16)
              v.set_y ((n * (mtx1*x + mtx3*y + mtx5)).to_integer_16)
              (x,y) := (v.cx.to_real_32,v.cy.to_real_32)
              v.set_cx ((m * (mtx0*x + mtx2*y + mtx4)).to_integer_16)
              v.set_cy ((n * (mtx1*x + mtx3*y + mtx5)).to_integer_16)
            }
            // Append vertices.                        
            (vertices = NULL).if {
              vertices := comp_verts
            } else {
              vertices.append_collection comp_verts
              free_vertices comp_verts
            }
          }
          // More components ?
          more := (flags & (1<<5)) != 0
        }
      }.elseif {number_of_contours < 0} then {
        // @TODO other compound variations?
        not_yet_implemented
      } else {
        // numberOfCounters == 0, do nothing
      }
    }
    ((vertices != NULL) && {vertices.count != num_vertices}).if {
      //"num_vertices:".print; vertices.count.print; '/'.print
      //num_vertices.print; '\n'.print
    }
    vertices
  )

  - get_glyph_h_metrics glyph_index:INTEGER :(INTEGER,INTEGER) <-
  ( + num_of_long_hor_metrics:UINTEGER_16
    + advance_width,left_side_bearing:INTEGER
    num_of_long_hor_metrics := ttushort(data+hhea + 34)
    (glyph_index < num_of_long_hor_metrics).if {
      advance_width    := ttshort(data + hmtx + 4*glyph_index)
      left_side_bearing:= ttshort(data + hmtx + 4*glyph_index + 2)
    } else {
      advance_width    := ttshort(data + hmtx + 4*(num_of_long_hor_metrics-1))
      left_side_bearing:= ttshort(data + hmtx + 4*num_of_long_hor_metrics + 2*(glyph_index - num_of_long_hor_metrics))
    }
    (advance_width,left_side_bearing)
  )

  - get_glyph_kern_advance (glyph1,glyph2:INTEGER) :INTEGER <-
  ( + l,r,m,result:INTEGER
    + needle, straw:UINTEGER_32
    + dta:NATIVE_ARRAY UINTEGER_8
    dta := data + kern
    //"kern:".print; kern.print; ' '.print
    //ttushort(dta+2).print; ' '.print
    //ttushort(dta+8).print; '\n'.print
    // we only look at the first table. it must be 'horizontal' and format 0.
    // number of tables, need at least 1
    // horizontal flag must be set in format
    ((kern!=0) && {ttushort(dta+2) >= 1} && {ttushort(dta+8) = 1}).if { 
      r := ttushort(dta+10) - 1
      needle := glyph1 << 16 | glyph2
      {(l <= r) && {result = 0}}.while_do {
        m := (l + r) >> 1
        straw := ttulong(dta+18+(m*6)); // note: unaligned read
        (needle < straw).if {
          r := m - 1
        }.elseif {needle > straw} then {
          l := m + 1
        } else {
          result := ttshort(dta+22+(m*6))
        }
      }
    }
    result
  )

  - get_codepoint_kern_advance (ch1,ch2:INTEGER) :INTEGER <-
  ( + result:INTEGER
    // if no kerning table, don't waste time looking up 
    // both codepoint->glyphs
    (kern!=0).if { 
      result := get_glyph_kern_advance
      (find_glyph_index ch1,find_glyph_index ch2)
    }
    result
  )

  - get_codepoint_h_metrics codepoint:INTEGER :(INTEGER,INTEGER) <-
  (
    get_glyph_h_metrics (find_glyph_index codepoint)
  )

  - get_font_v_metrics:(INTEGER,INTEGER,INTEGER) <-
  (
    ttshort(data+hhea + 4),
    ttshort(data+hhea + 6),
    ttshort(data+hhea + 8)
  )

  - get_font_bounding_box:(INTEGER,INTEGER,INTEGER,INTEGER) <-
  (
    ttshort(data + head + 36),ttshort(data + head + 38),
    ttshort(data + head + 40),ttshort(data + head + 42)
  )

  - scale_for_pixel_height height:REAL_32 :REAL_32 <-
  (
    height / (ttshort(data + hhea + 4) - ttshort(data + hhea + 6)).to_real_32
  )

  - scale_for_mapping_em_to_pixels pixels:REAL_32 :REAL_32 <-
  (
    pixels / ttushort(data + head + 18)
  )

  - free_shape v:TT_VERTEX <-
  (
    not_yet_implemented
    //STBTT_free(v, info->userdata)
  )


  // antialiasing software rasterizer
   
  - get_glyph_bitmap_subpixel (scale_x, scale_y:REAL_32)
  shift (shift_x,shift_y:REAL_32) 
  glyph gly:INTEGER :(BITMAP,INTEGER,INTEGER) <-
  // width x height x xoff x yoff
  [ ? {(scale_x != 0) || {scale_y != 0}}; ]
  ( + ix0,iy0,ix1,iy1:INTEGER
    + gbm:BITMAP
    + vertices:ARRAY TT_VERTEX
    + scal_x,scal_y:REAL_32
    
    vertices := get_glyph_shape gly
    
    (scal_x,scal_y) := (scale_x,scale_y)
    (scal_x = 0).if { scal_x := scal_y; }
    (scal_y = 0).if { scal_y := scal_x; }

    (ix0,iy0,ix1,iy1) := get_glyph_bitmap_box_subpixel gly
    scale (scal_x, scal_y) shift (shift_x, shift_y)

    // now we get the size   
    gbm := BITMAP.create (ix1 - ix0,iy1 - iy0)
    gbm.rasterize 0.35 vertex vertices scale (scal_x, scal_y)
    shift (shift_x, shift_y) offset (ix0, iy0) int 1
    
    free_vertices vertices
    gbm,ix0,iy0
  )

  - get_glyph_bitmap_box_subpixel glyph:INTEGER
  scale (scale_x,scale_y:REAL_32) shift (shift_x,shift_y:REAL_32) 
  :(INTEGER,INTEGER,INTEGER,INTEGER) <-  
  ( + x0,y0,x1,y1:INTEGER; // =0 suppresses compiler warning
    + ix0,iy0,ix1,iy1:INTEGER
    (x0,y0,x1,y1) := get_glyph_box glyph
    // move to integral bboxes (treating pixels as 
    // little squares, what pixels get touched)?
    ix0 := (scale_x *  x0 + shift_x).floor
    iy0 := (scale_y * -y1 + shift_y).floor
    ix1 := (scale_x *  x1 + shift_x).ceiling
    iy1 := (scale_y * -y0 + shift_y).ceiling
    //ix0.print; ' '.print; iy0.print; ','.print
    //ix1.print; ' '.print; iy1.print; '\n'.print
    ix0,iy0,ix1,iy1
  )

  - get_glyph_bitmap_box glyph:INTEGER scale (scale_x,scale_y:REAL_32)
  :(INTEGER,INTEGER,INTEGER,INTEGER) <-
  (
    get_glyph_bitmap_box_subpixel glyph scale (scale_x,scale_y) shift (0.0,0.0)
  )

  - get_codepoint_bitmap_box_subpixel codepoint:INTEGER
  scale (scale_x,scale_y:REAL_32) shift (shift_x,shift_y:REAL_32)
  :(INTEGER,INTEGER,INTEGER,INTEGER) <-
  (
    get_glyph_bitmap_box_subpixel (find_glyph_index codepoint) scale (scale_x,scale_y) shift (shift_x,shift_y)
  )

  - get_codepoint_bitmap_box codepoint:INTEGER 
  scale (scale_x,scale_y:REAL_32) :(INTEGER,INTEGER,INTEGER,INTEGER) <-
  (
    get_codepoint_bitmap_box_subpixel codepoint scale (scale_x, scale_y)
    shift (0.0,0.0)     
  )
  
  - get_codepoint_bitmap_subpixel (scale_x,scale_y:REAL_32) 
  shift (shift_x,shift_y:REAL_32) 
  code codepoint:INTEGER :(BITMAP,INTEGER,INTEGER) <-
  (
    get_glyph_bitmap_subpixel (scale_x, scale_y) shift (shift_x,shift_y) glyph (find_glyph_index codepoint) 
  )

  - make_codepoint_bitmap_subpixel output:NATIVE_ARRAY UINTEGER_8
  size (out_w,out_h,out_stride:INTEGER) scale (scale_x,scale_y:REAL_32)
  shift (shift_x,shift_y:REAL_32) code codepoint:INTEGER <-
  (
    make_glyph_bitmap_subpixel output size (out_w, out_h, out_stride)
    scale (scale_x,scale_y) shift (shift_x,shift_y) 
    glyph (find_glyph_index codepoint)
  )
  
  - make_glyph_bitmap output:NATIVE_ARRAY UINTEGER_8
  size (out_w,out_h:INTEGER) stride out_stride:INTEGER 
  scale (scale_x,scale_y:REAL_32) glyph glif:INTEGER <-
  (
    make_glyph_bitmap_subpixel output size (out_w,out_h)
    stride out_stride scale (scale_x, scale_y) shift (0.0,0.0) glyph glif
  )
  
  - make_glyph_bitmap_subpixel output:NATIVE_ARRAY UINTEGER_8
  size (out_w,out_h:INTEGER) stride out_stride:INTEGER scale (scale_x,scale_y:REAL_32)
  shift (shift_x,shift_y:REAL_32) glyph glif:INTEGER <-
  ( + ix0,iy0,tmp0,tmp1:INTEGER
    + gbm:BITMAP
    + vertices:ARRAY TT_VERTEX

    vertices := get_glyph_shape glif
    
    //"glif:".print; glif.print; '\n'.print
    //(vertices = NULL).if { "Vertices NULL\n".print; }
    
    (ix0,iy0,tmp0,tmp1) := get_glyph_bitmap_box_subpixel glif 
    scale (scale_x,scale_y) shift (shift_x,shift_y)
    gbm := BITMAP.create output size (out_w,out_h) stride out_stride

    ((out_w!=0) && {out_h!=0}).if {
      gbm.rasterize 0.35 vertex vertices 
      scale (scale_x,scale_y) shift (shift_x, shift_y) 
      offset (ix0,iy0) int 1
    }
    
    free_vertices vertices; //BSBS ATT.: Après bug avec éè comme texte!
  )

  - get_codepoint_bitmap (scale_x,scale_y:REAL_32) 
  code codepoint:INTEGER :(BITMAP,INTEGER,INTEGER) <-
  (
    get_codepoint_bitmap_subpixel (scale_x, scale_y) shift (0.0,0.0) code codepoint
  )
  
Public  
  
  // ARRAY TT_VERTEX
  
  - stock_array_tt_vertex:ARRAY (ARRAY TT_VERTEX) := ARRAY (ARRAY TT_VERTEX).create_with_capacity 32
  
  - alloc_vertices n:INTEGER :ARRAY TT_VERTEX <-
  ( + result:ARRAY TT_VERTEX
    (stock_array_tt_vertex.is_empty).if {
      result := ARRAY TT_VERTEX.create n
    } else {
      result := stock_array_tt_vertex.pop
      result.with_capacity n
      result.set_upper (n-1)
    }
    /* BSBSBS
    0.to (n-1) do { i:INTEGER
      result.add_last (TT_VERTEX.create)
    };*/
    result    
  )
  
  - free_vertices t:ARRAY TT_VERTEX <-
  (
    (t != NULL).if {
      //{t.is_empty}.until_do { t.pop.free; }; BSBSBS
      t.clear
      stock_array_tt_vertex.add_last t
    }
  )
  

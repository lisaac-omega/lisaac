Header

  + name := SU_DOKU;
  /*
  Du_doku Solver.
  */

Inherit

  - parent_clone:CLONE := CLONE

Private

  //
  // Data.
  //

  - array  :ARRAY2(INTEGER) := ARRAY2(INTEGER).create (9,9)

  //
  // Example.
  //

  - load_example <-
  (
    array.set_all_with 0
    array.at (1,0) put 9; array.at (2,0) put 7; array.at (3,0) put 8
    array.at (5,0) put 1; array.at (6,0) put 5
    array.at (1,1) put 4
    array.at (2,2) put 1; array.at (4,2) put 2; array.at (8,2) put 9
    array.at (6,3) put 4; array.at (7,3) put 8
    array.at (0,4) put 4; array.at (3,4) put 9; array.at (5,4) put 6; array.at (8,4) put 1
    array.at (1,5) put 5; array.at (2,5) put 2
    array.at (0,6) put 7; array.at (4,6) put 6; array.at (6,6) put 3
    array.at (7,7) put 6
    array.at (2,8) put 5; array.at (3,8) put 2; array.at (5,8) put 3
    array.at (6,8) put 8; array.at (7,8) put 1
  )

  //
  // Display.
  //

  - display <-
  ( + v:INTEGER


    0.to 8 do { y:INTEGER
      ((y % 3) = 0).if {
        "#####################################\n".print
      } else {
        "#---+---+---#---+---+---#---+---+---#\n".print
      }
      0.to 8 do { x:INTEGER
      ((x % 3) = 0).if {
        "# ".print
      } else {
        "| ".print
      }
      v := array.at (x,y)
      (v = 0).if {
        ' '.print
      } else {
        v.print
      }
      ' '.print
      }
      "#\n".print
    }
    "#####################################\n".print
  )

  //
  // Solver.
  //

  - is_good value:INTEGER to (x,y:INTEGER) :BOOLEAN <-
  ( + j,k,bx,by:INTEGER
    + result:BOOLEAN
    result := TRUE
    // Horizontal/Vertical test.
    {(j<9) && {result}}.while_do {
      result := (array.at (x,j) != value) && {array.at (j,y) != value}
      j := j + 1
    }
    (result).if {
      // Block test.
      by := y / 3 * 3
      bx := x / 3 * 3
      j := 0
      {(j < 3) && {result}}.while_do {
        k := 0
        {(k < 3) && {result}}.while_do {
          result := array.at (bx+k,by+j) != value
          k := k + 1
        }
        j := j + 1
      }
    }
    result
  )

  - solver (x,y:INTEGER) :BOOLEAN <-
  ( + px,py:INTEGER
    + v:INTEGER
    + is_found:BOOLEAN

    px := x
    py := y
    {(py<9) && {array.at (px,py) != 0}}.while_do {
      px := px + 1
      (px > 8).if {
        px := 0
        py := py + 1
      }
    }
    (py = 9).if {
      is_found := TRUE
    } else {
      v := 1
      {
        (is_good v to (px,py)).if {
          // I love English Girls (2005)
          array.at (px,py) put v
          is_found := solver (px,py)
          (is_found).if_false {
            array.at (px,py) put 0
          }
        }
        v := v + 1
      }.do_while {(v < 10) && {! is_found}}
    }
    is_found
  )

  - graph_table:ARRAY2(G_IN)

  - array_to_graph <-
  ( + val:INTEGER
    + in:G_IN
    0.to 8 do { x:INTEGER
      0.to 8 do { y:INTEGER
        val := array.at (x,y)
        in  := graph_table.at (x,y)
        in.text.clear
        (val != 0).if {
          val.append_in (in.text)
        }
        in.refresh
      }
    }
  )

  - graph_to_array <-
  ( + val:INTEGER
    + in:G_IN
    0.to 8 do { x:INTEGER
      0.to 8 do { y:INTEGER
        in  := graph_table.at (x,y)
        (in.text.is_empty).if {
          val := 0
        } else {
          val := in.text.to_integer
        }
        array.at (x,y) put val
      }
    }
  )

  - message:G_OUT

Public

  - run:G_WIN_OUT <-
  ( + c1,l1,c2,l2,r:G_EXPR
    + g:G_IN

    graph_table := ARRAY2(G_IN).create (9,9)
    0.to 2 do { xx:INTEGER
      c2 := NULL
      0.to 2 do { yy:INTEGER
        l1 := NULL
        0.to 2 do { x:INTEGER
          c1 := NULL
          0.to 2 do { y:INTEGER
            g := G_IN.create (2,1) justify (G_IN.center) action { in:G_IN
              in.text.remove_last 1
              ((in.text.count > 1) || {! in.text.first.in_range '1' to '9'}).if {
                in.text.clear
                message.text.copy " Error: Between 1 and 9"
              } else {
                message.text.copy " Ok."
              }
              message.refresh
            }
            graph_table.at (xx*3+x,yy*3+y) put g
            r := G_RAW.create g
            (c1 = NULL).if {
              c1 := r
            } else {
              c1 := c1 / r
            }
          }
          (l1 = NULL).if {
            l1 := c1
          } else {
            l1 := l1 | c1
          }
        }
        r := G_RAW.create l1
        (c2 = NULL).if {
          c2 := r
        } else {
          c2 := c2 / r
        }
      }
      (l2 = NULL).if {
        l2 := c2
      } else {
        l2 := l2 | c2
      }
    }
    G_WIN_OUT.create "Sudoku Solver" with (
      (
        G_BUTTON.create (G_OUT.create "Clear" justify (G_OUT.center))
        action { b:G_BUTTON
          + in:G_IN
          0.to 8 do { x:INTEGER
            0.to 8 do { y:INTEGER
              in := graph_table.at (x,y)
              in.text.clear
              in.refresh
            }
          }
        } |
        G_BUTTON.create (G_OUT.create "Load"  justify (G_OUT.center))
        action { b:G_BUTTON
          load_example
          array_to_graph
        } |
        G_BUTTON.create (G_OUT.create "Solve" justify (G_OUT.center))
        action { b:G_BUTTON
          graph_to_array
          solver (0,0).if {
            message.text.copy " Found !"
          } else {
            message.text.copy " Not found !"
          }
          message.refresh
          array_to_graph
        }
      ).fix_height /
      l2 /
      (G_RAW.create (message := G_OUT.create " ")).fix_height
    )
  )

  - main <-
  ( + choice:CHARACTER

    "====================================================\n\
    \Welcome the SU DOKU solver (V.1.0 by Sonntag Benoit)\n\
    \====================================================\n\n".print

    {
      "[a]:Load example. [b]:Display. [c]:New. [d]:Solve! [e]:Exit\n\
      \Choice ?\n".print
      {
        choice := STDIN.read_character
      }.do_until {choice.in_range 'a' to 'e'}
      STDIN.read_character

      choice
      .when 'a' then {
        load_example
        "Load example: Ok\n".print
      }
      .when 'b' then {
        display
      }
      .when 'c' then {
        0.to 8 do { y:INTEGER
          0.to 8 do { x:INTEGER
            "Line #".print
            (y+1).print
            " Column #".print
            (x+1).print
            " ?\n".print
            {
              choice := STDIN.read_character
            }.do_until {(choice.in_range '1' to '9') || {choice = '\n'}}
            (choice = '\n').if {
              array.at (x,y) put 0
            } else {
              array.at (x,y) put (choice.decimal_value)
              STDIN.read_character
            }
          }
        }
      }
      .when 'd' then {
        "Solver result: ".print
        solver (0,0).if {
          "Found !\n".print
        } else {
          "Not found!\n".print
        }
      }
    }.do_while {choice != 'e'}
    "Good bye!\n".print
  )

Header
  
  + name := CONVERSION_BINAIRE;
  /*
The classical factorial example in Lisaac Ω.
  
In this example, the traditional recursive implementation of the factorial function, both the tail-recursive and non-tail-recursive versions, as well as an example with signed integers that do not overflow.
  */

Public
  
  - convbin (n:INTEGER) :STRING <-
  // Récursif non-terminal.
  // Joli, mais catastrophique en allocation mémoire...
  ( + result:STRING
    if (n < 2) then {
      result := n.to_string
    } else {
      result := convbin (n / 2) + ((n % 2).to_string)
    }
    result
  )
  
  - main <-
  ( + n:INTEGER;  
    if (COMMAND_ARGS upper != 1) then {
      OUT # "usage: " # COMMAND_ARGS.at 0 # " <n>" # '\n'
      SYSTEM exit 1
    }
    n := COMMAND_ARGS at 1 .to_integer
    OUT # "recursif non terminal: " # (convbin n) # '\n'
    OUT # "recursif terminal:     " # (convbin n acc "") # '\n'
    OUT # "itératif:              " # (convbin n itératif) # '\n'
  );
  
  - convbin (n:INTEGER) acc acc:STRING :STRING <-
  // Récursif terminal.
  // Toujours aussi catastrophique en allocation mémoire...
  ( + result:STRING
    if (n < 2) then {
      result := n.to_string + acc
    } else {
      result := convbin (n / 2) acc ((n % 2).to_string + acc)
    }
    result
  )
  
  - convbin (n:INTEGER) itératif :STRING <-
  //  La solution à retenir.
  ( + v:INTEGER;
    + result:STRING_BUFFER;
    STRING.tmp { buf:STRING_BUFFER
      v := n;
      while { v != 0 } do {
        if ((v % 2) = 0) then {
          buf.add_last '0'
        } else {
          buf.add_last '1'
        }
        v := v / 2
      }
      result := STRING_BUFFER . create (buf.count)
      from (buf.upper) down_to 0 do { idx:INTEGER
        result.add_last (buf.at idx)
      }
    }
    result
  )
  
  
  
Header
  
  + name := KNUCLEOTIDE;
  
Inherit
  
  - parent_clone:CLONE := CLONE
  
Public
  
  - buffer:STRING_BUFFER
  
  - dico:HSET SORTER
  
  - idf:STRING_ALIAS := "GGTATTTTAATTTATAGT"
  - key:SORTER
  - key2:SORTER
  
  - main <-
  (
    key := SORTER.my_clone
    key2 := SORTER.my_clone
    // Read file.
    buffer := STRING_BUFFER.create 10240
    {      
      buffer.clear
      STDIN.read_line_in buffer
    }.do_until {buffer.has_prefix ">THREE"}
    buffer.clear
    
    {! STDIN.end_of_input}.while_do {      
      STDIN.read_line_in buffer
    }
    buffer.to_upper
    // Compute frequently.
    dico := HSET SORTER.create
    
    //
    sort 1
    sort 2
    //
    key2.init_with (idf.to_external)
    display 3
    display 4
    display 6
    display 12
    display 18
    
  )
  
  - count n:INTEGER <-
  (     
    dico.clear
    (buffer.lower).to (buffer.upper-n+1) do { j:INTEGER
      key.init_with (buffer.to_external + (j - 1))
      //
      key.set_count n
      inc_key
    }
  )
  
  - inc_key <-
  ( + new_key:SORTER
        
    new_key := dico.reference_at key
    (new_key = NULL).if {      
      new_key := key.my_clone
      dico.add new_key
    } else {
      new_key.inc_freq
    }
  )
  
  - display n:INTEGER <-
  ( + ref:SORTER
    
    count n
    key2.set_count n
    ref := dico.reference_at key2
    (ref = NULL).if {
      '0'.print
    } else {
      ref.freq.print
    }
    '\t'.print
    key2.print
    '\n'.print
  )
  
  - array:NATIVE_ARRAY(SORTER) := NATIVE_ARRAY(SORTER).create 16
    
  - sort n:INTEGER <-
  ( + cnt,low,up,i,freq:INTEGER
    + swap:BOOLEAN
    + s:SORTER
    + tmp:SORTER
    
    count n
    (dico.lower).to (dico.upper) do { j:INTEGER
      s := dico.at j
      array.put s to (j-1)
      cnt := cnt + s.freq
    }
    
    low := 0
    up  := dico.count - 2
    {
      swap := FALSE
      (low).to (up) do { j:INTEGER
        (array.at j.freq < array.at (j+1).freq).if {
          tmp := array.at j
          array.put (array.at (j+1)) to j
          array.put tmp to (j+1)
          swap := TRUE
        }
        i := dico.count - 2 - j
        (array.at i.freq < array.at (i+1).freq).if {
          tmp := array.at i
          array.put (array.at (i+1)) to i
          array.put tmp to (i+1)
          swap := TRUE
        }

      }
      low := low + 1
      up  := up  - 1
    }.do_while {swap}
    0.to (dico.count-1) do { j:INTEGER
      s := array.at j
      s.print
      freq := s.freq
      ((100.0*freq)/cnt).print_format_c " %.3f\n"
    }
    '\n'.print
  )

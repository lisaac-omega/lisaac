Header

  + name        := ITM_EXTERNAL;

  /*External C without type result*/

Inherit

  + parent_itm_extern:Expanded ITM_EXTERN

Public

  //
  // Constructor
  //

  - create p:POSITION text n:STRING_ALIAS :SELF <-
  ( + result:SELF
    result := clone
    result.make p text n
    result
  )

  - make p:POSITION text n:STRING_ALIAS <-
  (
    position := p
    extern   := n
  )

  //
  // Runnable
  //

  - to_run_expr:EXPR <-
  ( + result:EXPR
    + lst_acc:ARRAY EXPR
    + num:INTEGER
    + exp1,exp2,exp3:EXPR
    + left,right:EXPR
    + type:TYPE_FULL
    
    extern.is_integer.if {
      num := extern.to_integer
      (num > 31).if {
	syntax_error (position,"Unknown external lisaac code (0..31).")
      }
      num
      .when 0 then { // is_expanded_type:BOOLEAN
	exp1 := profil_slot.argument_list.first.read position
	result := IS_EXPANDED.create position receiver exp1
      }
      .when 1 then { // type_id_intern:INTEGER
        result := GET_TYPE_ID.create position receiver (profil_slot.argument_list.first.type)
      }
      .when 2 then { // INTEGER > INTEGER -> BOOLEAN.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_SUP.create position with left and right
      }
      .when 3 then { // INTEGER - INTEGER -> INTEGER.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_SUB.create position with left and right
      }
      .when 4 then { // INTEGER * INTEGER -> INTEGER.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_MUL.create position with left and right
      }
      .when 5 then { // INTEGER / INTEGER -> INTEGER.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_DIV.create position with left and right
      }
      .when 6 then { // INTEGER & INTEGER -> INTEGER.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_AND.create position with left and right
      }
      .when 7 then { // INTEGER >> INTEGER -> INTEGER.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_SHIFT_R.create position with left and right
      }
      .when 8 then { // INTEGER << INTEGER -> INTEGER.
	left   := profil_slot.argument_list.first .read position
	right  := profil_slot.argument_list.at 1.read position
	result := EXPR_SHIFT_L.create position with left and right
      }
      .when 9 then { // put OBJECT to INTEGER.
	exp1 := profil_slot.argument_list.first .read position
	exp2 := profil_slot.argument_list.at 1.read position
	exp3 := profil_slot.argument_list.at 2.read position
	result := PUT_TO.create position base exp1 index exp3 value exp2
      }
      .when 10 then { // item INTEGER -> OBJECT.
	exp1 := profil_slot.argument_list.first .read position
	exp2 := profil_slot.argument_list.at 1.read position
	result := ITEM.create position base exp1 index exp2
      }
      .when 11 then { // OLD debug_level -> INTEGER.
	not_yet_implemented
      }
      .when 12 then { // object_size -> INTEGER.
        result := SIZE_OF.create position receiver (profil_slot.argument_list.first.type)
      }
      .when 13 then { // CAST SRC TO DST.on src:SRC :DST.
        type := profil_slot.result_list.first.type
        exp2 := profil_slot.argument_list.second.read position
        result := CAST.create type value exp2
        
        //(type.is_scalar).if {        
        /*
        (type.raw.name == "STRING").if_false {
          result := CAST.create type value exp2
        } else {
          warning_error (position,"cast creation.")
          result := CAST_CREATION.create type value exp2
        }
        */
      }
      .when 14 then { // OLD `is_cop_actif' for COP
        not_yet_implemented
      }
      .when 15 then { // is_cop_type:BOOLEAN
        type := profil_slot.argument_list.first.type
        ((is_cop) && {type.prototype.style = '-'}).if {
          result := PROTOTYPE_CST.create position type (type_true.default)
        } else {
          result := PROTOTYPE_CST.create position type (type_false.default)
        }
      }
      .when 16 then { // LIST.upper:INTEGER
        not_yet_implemented
      }
      .when 17 then { // LIST.at index:INTEGER :E
        not_yet_implemented
      }
      .when 18 then { // OLD compiler_inlining_level -> INTEGER.
	not_yet_implemented
      }
      .when 19 then { // OLD compiler_optimization -> BOOLEAN.
        not_yet_implemented
      }
      .when 20 then { // compiler_built_on -> STRING_ALIAS.
        string_tmp.clear
        DATE.create_now.append_in string_tmp
        string_tmp.add_last ' '
        TIME.now.append_in string_tmp
        result := STRING_CST.create position text (string_tmp.to_string_alias) length (string_tmp.count)
      }
      .when 21 then { // OLD debug_with_code -> BOOLEAN.
        not_yet_implemented
      }
      .when 22 then { // compile_time -> INTEGER.
        result := INTEGER_CST.create position value (TIME.now.to_csecond) type (type_integer.default)
      }
      .when 23 then { // compile_date -> UINTEGER_32.
        result := INTEGER_CST.create position value (DATE.create_now.encode) type (type_uinteger_32.default)
      }
      .when 24 then { // OBJECT.type_name -> STRING_ALIAS
        type := profil_slot.argument_list.first.type
        string_tmp.clear
        type.raw.append_name_in string_tmp
        result := STRING_CST.create position text (string_tmp.to_string_alias) length (string_tmp.count)
      }
      .when 25 then { // OBJECT.foreach_intern_data action:{ (STRING_ALIAS,STRING_ALIAS,T,E); }
        forall_data_product
        result := PROTOTYPE_CST.create position type (TYPE_VOID.default)
      }
      .when 26 then {        type := profil_slot.result_list.first.type
        exp1 := profil_slot.argument_list.first.read position
        result := READ_LIP.create exp1 type type
      }
      .when 27 to 31 then { // FREE
        syntax_error (position,"Free external lisaac code.")
      }
    } else {
      lst_acc := get_access
      result  := EXTERNAL_C.create position text last_code
      access lst_acc persistant TRUE type (TYPE_VOID.default)
    }
    result
  )

Private

  //
  // Reflexivity
  //

  - forall_data_product <-
  ( + type:TYPE_FULL
    + slot:SLOT
    + sl_dta:SLOT_DATA
    type := profil_slot.argument_list.first.type
    (type.raw.prototype.is_mapping).if_false {
      semantic_error (position,"Sorry, not yet implemented.")
    }
    (type.slot_run.lower).to (type.slot_run.upper) do { i:INTEGER
      slot := type.slot_run.at i
      sl_dta := slot.slot_data_intern
      (sl_dta != NULL).if {
        product_access sl_dta
        (slot.slot_data_list != NULL).if {
          (slot.slot_data_list.lower).to (slot.slot_data_list.upper) do { j:INTEGER
            product_access (slot.slot_data_list.at j)
          }
        }
      }
    }
  )

  - product_access slot:SLOT_DATA <-
  ( + arg_sec,arg_nam,arg_typ,arg_val,rec:EXPR
    + args:ARRAY EXPR

    (slot.style = '+').if {
      // Section name.
      string_tmp.clear
      slot.id_section.append_in string_tmp
      arg_sec := STRING_CST.create position text (string_tmp.to_string_alias) length (string_tmp.count)
      // Name slot.
      arg_nam := STRING_CST.create position text (slot.name) length (slot.name.count)
      // Type.
      arg_typ := PROTOTYPE_CST.create position type (slot.type)
      // Value.
      arg_val := slot.read position with (profil_slot.argument_list.first.read position)
      // {}.value.
      rec := (profil_slot.argument_list.second.read position)
      args := ARRAY EXPR .create_with_capacity 5
      args.add_last (rec.my_copy)
      args.add_last arg_sec
      args.add_last arg_nam
      args.add_last arg_typ
      args.add_last arg_val
      list_current.add_last (
        NODE.new_block position receiver rec with args
      )
    }
  )

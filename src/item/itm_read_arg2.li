Header

  + name    := ITM_READ_ARG2;

  /*For send message with two argument (receiver + argument)
   or simple binary message*/

Inherit

  + parent_itm_read:Expanded ITM_READ

Public

  - is_affect:POSITION <-
  ( + result:POSITION

    (arg_first != NULL).if {
      result := arg_first.position
    } else {
      result := arg_second.is_affect
    }
    result
  )

  //
  // Data
  //

  + arg_first:ITM_CODE

  + arg_second:ITM_CODE

  //
  // Constructor
  //

  - create p:POSITION name n:STRING_ALIAS args (a1,a2:ITM_CODE) :SELF <-
  ( + result:SELF
    result := clone
    result.make p name n args (a1,a2)
    result
  )

  - make p:POSITION name n:STRING_ALIAS args (a1,a2:ITM_CODE) <-
  (
    ? { a2 != NULL }
    position   := p
    name := n
    arg_first  := a1
    arg_second := a2
  )

  //
  // Runnable
  //
  
  - to_run:INSTR <-
  ( + rd0:Strict ITM_READ
    + rd1:Strict ITM_READ_ARG1
    rd0 ?= arg_first
    rd1 ?= arg_first
    ((name = "__infix_equal") && {(rd0 != NULL) || {rd1 != NULL}}).if {      
      warning_error (position,"Useless comparaison. Possible ambiguity between ':=' and '='.")
    }
    to_run_expr
  )
  
  - to_run_expr:EXPR <-
  ( + result:EXPR
    + l_arg:ARRAY ITM_CODE
    + v1,v2:EXPR
    + em1,em2:EXPR_MULTIPLE
    + ext:EXPR_BINARY_CMP
    (name = "__infix_equal").if {
      ext := EXPR_EQUAL
    }.elseif {name = "__infix_not_equal"} then {
      ext := EXPR_NOT_EQUAL
    }
    (ext != NULL).if {      
      v1 := arg_first .to_run_expr
      v2 := arg_second.to_run_expr
      (v1,v2) := cmp_verify position between (v1,v2)
      em1 ?= v1
      (em1 != NULL).if {
        em2 ?= v2
        result := product_cmp (em1.first, em2.first) ext ext pos position
        (em1.lower+1).to (em1.upper) do { j:INTEGER
          v2 := product_cmp (em1.at j, em2.at j) ext ext pos position
          (name = "__infix_equal").if {
            result := EXPR_AND_AND_LOGIC.create position with result and v2
          } else {
            result := EXPR_OR_OR_LOGIC.create position with result and v2
          }
        }
      } else {
        result := product_cmp (v1,v2) ext ext pos position
      }
    } else {
      l_arg := ALIAS_ARRAY ITM_CODE .new
      l_arg.add_last arg_second
      result := to_run_with arg_first args l_arg
    }
    result
  )


